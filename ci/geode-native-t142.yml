groups:
- jobs:
  - build-windows-2016-vs-2017-debug
  - build-windows-2016-vs-2017-release
  - build-windows-2019-vs-2019-debug
  - build-windows-2019-vs-2019-release
  - build-rhel-7-debug
  - build-rhel-7-release
  - build-rhel-8-debug
  - build-rhel-8-release
  - build-ubuntu-16.04-debug
  - build-ubuntu-16.04-release
  - build-ubuntu-18.04-debug
  - build-ubuntu-18.04-release
  - build-ubuntu-20.04-debug
  - build-ubuntu-20.04-release
  - check-source
  name: builds
- jobs:
  - update-pipeline
  name: meta
- jobs:
  - update-pipeline
  - build-windows-2016-vs-2017-debug
  - build-windows-2016-vs-2017-release
  - build-windows-2019-vs-2019-debug
  - build-windows-2019-vs-2019-release
  - build-rhel-7-debug
  - build-rhel-7-release
  - build-rhel-8-debug
  - build-rhel-8-release
  - build-ubuntu-16.04-debug
  - build-ubuntu-16.04-release
  - build-ubuntu-18.04-debug
  - build-ubuntu-18.04-release
  - build-ubuntu-20.04-debug
  - build-ubuntu-20.04-release
  - check-source
  - packer-build-windows-2016-vs-2017
  - packer-build-windows-2019-vs-2019
  - packer-build-rhel-7
  - packer-build-rhel-8
  - packer-build-ubuntu-16-04
  - packer-build-ubuntu-18-04
  - packer-build-ubuntu-20-04
  - docker-task-image
  - docker-clang-tools-image
  - version-source
  - bump-minor-version
  - github-pre-release
  - native-passed
  name: all
- jobs:
  - packer-build-windows-2016-vs-2017
  - packer-build-windows-2019-vs-2019
  - packer-build-rhel-7
  - packer-build-rhel-8
  - packer-build-ubuntu-16-04
  - packer-build-ubuntu-18-04
  - packer-build-ubuntu-20-04
  - docker-task-image
  - docker-clang-tools-image
  name: images
- jobs:
  - version-source
  - bump-minor-version
  name: version
jobs:
- name: build-windows-2016-vs-2017-debug
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: version
        passed:
        - version-source
        trigger: true
      - get: source
        passed:
        - version-source
        trigger: true
      - get: task-image
  - do:
    - do:
      - in_parallel:
          fail_fast: true
          steps:
          - get: gcloud-image
          - get: geode-native-develop-build-windows-2016-vs-2017-gci
      - in_parallel:
          fail_fast: true
          steps:
          - config:
              inputs:
              - name: geode-native-develop-build-windows-2016-vs-2017-gci
                path: image
              outputs:
              - name: instance
              platform: linux
              run:
                args:
                - -c
                - |-
                  set -ueo pipefail
                  GOOGLE_PROJECT=apachegeode-ci
                  GOOGLE_ZONE=us-central1-a
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi
                  ssh_key_file=${INSTANCE_DIR}/identity
                  ssh_pubkey_file=${ssh_key_file}.pub
                  ssh-keygen -m pem  -t rsa -f ${ssh_key_file} -C "${INSTANCE_USER}" -N '' <<< y
                  ssh_pubkey=$(cat ${ssh_pubkey_file})
                  ssh_keys_file=${INSTANCE_DIR}/ssh_keys_file
                  echo "${INSTANCE_USER}:${ssh_pubkey}" > ${ssh_keys_file}
                  instance_name=build-$(cat /proc/sys/kernel/random/uuid)
                  image_name=$(cat image/name)
                  time_to_live=$(( $(date +%s) + ( 4 * 60 * 60 ) ))
                  instance_file=${INSTANCE_DIR}/instance.sh
                  gcloud compute instances create ${instance_name} \
                      --format='config[export](name,networkInterfaces[0].accessConfigs[0].natIP)' \
                      --project=${GOOGLE_PROJECT} \
                      --zone=${GOOGLE_ZONE} \
                      --subnet=default \
                      --machine-type=e2-standard-16 \
                      --boot-disk-size=200GB \
                      --boot-disk-type=pd-standard \
                      --boot-disk-device-name=${instance_name} \
                      --image-project=${GOOGLE_PROJECT} \
                      --image=${image_name} \
                      --metadata-from-file ssh-keys=${ssh_keys_file} \
                      --labels=time-to-live=${time_to_live},pipeline-name=geode-native-develop,build-config=debug \
                      > ${instance_file}
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi

                  SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                  ssh_key_file=${INSTANCE_DIR}/identity
                  if [ ! -r "${ssh_key_file}" ]; then
                    echo "${ssh_key_file} not readable."
                    exit 1
                  fi

                  instance_file=${INSTANCE_DIR}/instance.sh
                  if [ ! -r "${instance_file}" ]; then
                    echo "${instance_file} not readable."
                    exit 1
                  fi

                  external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                  function remote_shell {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                  }

                  function remote_download {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                  }

                  function remote_download_directory {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                  }

                  function remote_upload {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                  }
                  SSH_OPTIONS="${SSH_OPTIONS} -o ConnectTimeout=10"
                  echo "Waiting for ssh on ${instance_name} to be ready."
                  console_file=$(mktemp)
                  console_next=0
                  while ! remote_shell echo ready 2>/dev/null ; do
                    gcloud compute instances get-serial-port-output ${instance_name} \
                        --start ${console_next} \
                        --project=${GOOGLE_PROJECT} \
                        --zone=${GOOGLE_ZONE} \
                        --format='value[separator="
                  "](next,contents)' \
                        > ${console_file}
                    tmp_next=$(head -n 1 ${console_file})
                    if (( tmp_next != console_next )); then
                      console_next=${tmp_next}
                      sed '1d;s/\x1b\[[0-9;]*[JH]//g' ${console_file}
                    fi
                  done
                path: bash
            image: gcloud-image
            task: instance-create
          - get: geode-latest
    - in_parallel:
        fail_fast: true
        steps:
        - config:
            inputs:
            - name: instance
            - name: source
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_upload source .
              path: bash
          image: task-image
          task: upload-source
        - config:
            inputs:
            - name: instance
            - name: geode-latest
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                geode_version=$(cat geode-latest/version)
                geode_name="apache-geode-${geode_version}"
                geode_artifact="${geode_name}.tgz"
                remote_upload geode-latest/${geode_artifact} .
                remote_shell cmake -E tar xvf ${geode_artifact}
                remote_shell cmake -E rename ${geode_name} geode
              path: bash
          image: task-image
          task: upload-geode
    - config:
        inputs:
        - name: instance
        - name: version
        - name: source
        outputs:
        - name: package
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            pushd source
            git_url=$(git remote get-url origin)
            git_rev=$(git rev-parse HEAD)
            popd
            version=$(cat version/number)
            builddate=$(date "+%Y-%m-%d")
            remote_shell cmake -E make_directory build
            remote_shell cmake -E time cmake -E chdir build cmake ../source ${CMAKE_CONFIGURE_FLAGS} \
                -DCMAKE_BUILD_TYPE=${CMAKE_CONFIG} \
                -DGEODE_ROOT=../geode \
                -DPRODUCT_VERSION=${version} \
                -DPRODUCT_BUILDDATE=${builddate} \
                -DPRODUCT_SOURCE_REVISION=${git_rev} \
                -DPRODUCT_SOURCE_REPOSITORY=${git_url}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} --target docs -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake -E chdir build cpack -C ${CMAKE_CONFIG} -G "${CPACK_GENERATORS}" | tee cpack.out
            packages=$(awk '/^CPack: - package: / {print $4}' cpack.out)
            for package in ${packages}; do
              remote_download ${package} package/
            done
            checksums=$(awk '/^CPack: - checksum file: / {print $5}' cpack.out)
            for checksum in ${checksums}; do
              remote_download ${checksum} package/
            done
          path: bash
      image: task-image
      task: build
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration/test ctest -C ${CMAKE_CONFIG} -j4 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/clicache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: net-unmanaged-unit-tests
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/clicache/test2 ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: net-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/clicache/integration-test2 ctest -C ${CMAKE_CONFIG} -j6 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: net-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/clicache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: net-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=Debug --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-integration-test
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-session-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-session-integration-test
      timeout: 10m
    ensure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                GOOGLE_PROJECT=apachegeode-ci
                GOOGLE_ZONE=us-central1-a
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                instance_name=$(source ${instance_file} && echo -n ${name})

                gcloud compute instances delete ${instance_name} \
                    --project=${GOOGLE_PROJECT} \
                    --zone=${GOOGLE_ZONE} \
                    --delete-disks=all \
                    --quiet
              path: bash
          image: gcloud-image
          task: instance-delete
    on_failure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            outputs:
            - name: build
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_download_directory build .
              path: bash
          image: task-image
          task: download-build
  - in_parallel:
      fail_fast: true
      steps:
      - params:
          file: package/*-Windows-64bit.zip
        put: package-windows-2016-vs-2017-debug-archive
      - params:
          file: package/*-Windows-64bit.zip.sha512
        put: package-windows-2016-vs-2017-debug-archive.sha512
  public: true
- name: build-windows-2016-vs-2017-release
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: version
        passed:
        - version-source
        trigger: true
      - get: source
        passed:
        - version-source
        trigger: true
      - get: task-image
  - do:
    - do:
      - in_parallel:
          fail_fast: true
          steps:
          - get: gcloud-image
          - get: geode-native-develop-build-windows-2016-vs-2017-gci
      - in_parallel:
          fail_fast: true
          steps:
          - config:
              inputs:
              - name: geode-native-develop-build-windows-2016-vs-2017-gci
                path: image
              outputs:
              - name: instance
              platform: linux
              run:
                args:
                - -c
                - |-
                  set -ueo pipefail
                  GOOGLE_PROJECT=apachegeode-ci
                  GOOGLE_ZONE=us-central1-a
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi
                  ssh_key_file=${INSTANCE_DIR}/identity
                  ssh_pubkey_file=${ssh_key_file}.pub
                  ssh-keygen -m pem  -t rsa -f ${ssh_key_file} -C "${INSTANCE_USER}" -N '' <<< y
                  ssh_pubkey=$(cat ${ssh_pubkey_file})
                  ssh_keys_file=${INSTANCE_DIR}/ssh_keys_file
                  echo "${INSTANCE_USER}:${ssh_pubkey}" > ${ssh_keys_file}
                  instance_name=build-$(cat /proc/sys/kernel/random/uuid)
                  image_name=$(cat image/name)
                  time_to_live=$(( $(date +%s) + ( 4 * 60 * 60 ) ))
                  instance_file=${INSTANCE_DIR}/instance.sh
                  gcloud compute instances create ${instance_name} \
                      --format='config[export](name,networkInterfaces[0].accessConfigs[0].natIP)' \
                      --project=${GOOGLE_PROJECT} \
                      --zone=${GOOGLE_ZONE} \
                      --subnet=default \
                      --machine-type=e2-standard-16 \
                      --boot-disk-size=200GB \
                      --boot-disk-type=pd-standard \
                      --boot-disk-device-name=${instance_name} \
                      --image-project=${GOOGLE_PROJECT} \
                      --image=${image_name} \
                      --metadata-from-file ssh-keys=${ssh_keys_file} \
                      --labels=time-to-live=${time_to_live},pipeline-name=geode-native-develop,build-config=release \
                      > ${instance_file}
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi

                  SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                  ssh_key_file=${INSTANCE_DIR}/identity
                  if [ ! -r "${ssh_key_file}" ]; then
                    echo "${ssh_key_file} not readable."
                    exit 1
                  fi

                  instance_file=${INSTANCE_DIR}/instance.sh
                  if [ ! -r "${instance_file}" ]; then
                    echo "${instance_file} not readable."
                    exit 1
                  fi

                  external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                  function remote_shell {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                  }

                  function remote_download {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                  }

                  function remote_download_directory {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                  }

                  function remote_upload {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                  }
                  SSH_OPTIONS="${SSH_OPTIONS} -o ConnectTimeout=10"
                  echo "Waiting for ssh on ${instance_name} to be ready."
                  console_file=$(mktemp)
                  console_next=0
                  while ! remote_shell echo ready 2>/dev/null ; do
                    gcloud compute instances get-serial-port-output ${instance_name} \
                        --start ${console_next} \
                        --project=${GOOGLE_PROJECT} \
                        --zone=${GOOGLE_ZONE} \
                        --format='value[separator="
                  "](next,contents)' \
                        > ${console_file}
                    tmp_next=$(head -n 1 ${console_file})
                    if (( tmp_next != console_next )); then
                      console_next=${tmp_next}
                      sed '1d;s/\x1b\[[0-9;]*[JH]//g' ${console_file}
                    fi
                  done
                path: bash
            image: gcloud-image
            task: instance-create
          - get: geode-latest
    - in_parallel:
        fail_fast: true
        steps:
        - config:
            inputs:
            - name: instance
            - name: source
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_upload source .
              path: bash
          image: task-image
          task: upload-source
        - config:
            inputs:
            - name: instance
            - name: geode-latest
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                geode_version=$(cat geode-latest/version)
                geode_name="apache-geode-${geode_version}"
                geode_artifact="${geode_name}.tgz"
                remote_upload geode-latest/${geode_artifact} .
                remote_shell cmake -E tar xvf ${geode_artifact}
                remote_shell cmake -E rename ${geode_name} geode
              path: bash
          image: task-image
          task: upload-geode
    - config:
        inputs:
        - name: instance
        - name: version
        - name: source
        outputs:
        - name: package
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            pushd source
            git_url=$(git remote get-url origin)
            git_rev=$(git rev-parse HEAD)
            popd
            version=$(cat version/number)
            builddate=$(date "+%Y-%m-%d")
            remote_shell cmake -E make_directory build
            remote_shell cmake -E time cmake -E chdir build cmake ../source ${CMAKE_CONFIGURE_FLAGS} \
                -DCMAKE_BUILD_TYPE=${CMAKE_CONFIG} \
                -DGEODE_ROOT=../geode \
                -DPRODUCT_VERSION=${version} \
                -DPRODUCT_BUILDDATE=${builddate} \
                -DPRODUCT_SOURCE_REVISION=${git_rev} \
                -DPRODUCT_SOURCE_REPOSITORY=${git_url}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} --target docs -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake -E chdir build cpack -C ${CMAKE_CONFIG} -G "${CPACK_GENERATORS}" | tee cpack.out
            packages=$(awk '/^CPack: - package: / {print $4}' cpack.out)
            for package in ${packages}; do
              remote_download ${package} package/
            done
            checksums=$(awk '/^CPack: - checksum file: / {print $5}' cpack.out)
            for checksum in ${checksums}; do
              remote_download ${checksum} package/
            done
          path: bash
      image: task-image
      task: build
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration/test ctest -C ${CMAKE_CONFIG} -j4 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/clicache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: net-unmanaged-unit-tests
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/clicache/test2 ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: net-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/clicache/integration-test2 ctest -C ${CMAKE_CONFIG} -j6 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: net-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/clicache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: net-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=RelWithDebInfo --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-integration-test
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-session-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-session-integration-test
      timeout: 10m
    ensure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                GOOGLE_PROJECT=apachegeode-ci
                GOOGLE_ZONE=us-central1-a
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                instance_name=$(source ${instance_file} && echo -n ${name})

                gcloud compute instances delete ${instance_name} \
                    --project=${GOOGLE_PROJECT} \
                    --zone=${GOOGLE_ZONE} \
                    --delete-disks=all \
                    --quiet
              path: bash
          image: gcloud-image
          task: instance-delete
    on_failure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            outputs:
            - name: build
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_download_directory build .
              path: bash
          image: task-image
          task: download-build
  - in_parallel:
      fail_fast: true
      steps:
      - params:
          file: package/*-Windows-64bit.zip
        put: package-windows-2016-vs-2017-release-archive
      - params:
          file: package/*-Windows-64bit.zip.sha512
        put: package-windows-2016-vs-2017-release-archive.sha512
  public: true
- name: build-windows-2019-vs-2019-debug
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: version
        passed:
        - version-source
        trigger: true
      - get: source
        passed:
        - version-source
        trigger: true
      - get: task-image
  - do:
    - do:
      - in_parallel:
          fail_fast: true
          steps:
          - get: gcloud-image
          - get: geode-native-develop-build-windows-2019-vs-2019-gci
      - in_parallel:
          fail_fast: true
          steps:
          - config:
              inputs:
              - name: geode-native-develop-build-windows-2019-vs-2019-gci
                path: image
              outputs:
              - name: instance
              platform: linux
              run:
                args:
                - -c
                - |-
                  set -ueo pipefail
                  GOOGLE_PROJECT=apachegeode-ci
                  GOOGLE_ZONE=us-central1-a
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi
                  ssh_key_file=${INSTANCE_DIR}/identity
                  ssh_pubkey_file=${ssh_key_file}.pub
                  ssh-keygen -m pem  -t rsa -f ${ssh_key_file} -C "${INSTANCE_USER}" -N '' <<< y
                  ssh_pubkey=$(cat ${ssh_pubkey_file})
                  ssh_keys_file=${INSTANCE_DIR}/ssh_keys_file
                  echo "${INSTANCE_USER}:${ssh_pubkey}" > ${ssh_keys_file}
                  instance_name=build-$(cat /proc/sys/kernel/random/uuid)
                  image_name=$(cat image/name)
                  time_to_live=$(( $(date +%s) + ( 4 * 60 * 60 ) ))
                  instance_file=${INSTANCE_DIR}/instance.sh
                  gcloud compute instances create ${instance_name} \
                      --format='config[export](name,networkInterfaces[0].accessConfigs[0].natIP)' \
                      --project=${GOOGLE_PROJECT} \
                      --zone=${GOOGLE_ZONE} \
                      --subnet=default \
                      --machine-type=e2-standard-16 \
                      --boot-disk-size=200GB \
                      --boot-disk-type=pd-standard \
                      --boot-disk-device-name=${instance_name} \
                      --image-project=${GOOGLE_PROJECT} \
                      --image=${image_name} \
                      --metadata-from-file ssh-keys=${ssh_keys_file} \
                      --labels=time-to-live=${time_to_live},pipeline-name=geode-native-develop,build-config=debug \
                      > ${instance_file}
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi

                  SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                  ssh_key_file=${INSTANCE_DIR}/identity
                  if [ ! -r "${ssh_key_file}" ]; then
                    echo "${ssh_key_file} not readable."
                    exit 1
                  fi

                  instance_file=${INSTANCE_DIR}/instance.sh
                  if [ ! -r "${instance_file}" ]; then
                    echo "${instance_file} not readable."
                    exit 1
                  fi

                  external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                  function remote_shell {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                  }

                  function remote_download {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                  }

                  function remote_download_directory {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                  }

                  function remote_upload {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                  }
                  SSH_OPTIONS="${SSH_OPTIONS} -o ConnectTimeout=10"
                  echo "Waiting for ssh on ${instance_name} to be ready."
                  console_file=$(mktemp)
                  console_next=0
                  while ! remote_shell echo ready 2>/dev/null ; do
                    gcloud compute instances get-serial-port-output ${instance_name} \
                        --start ${console_next} \
                        --project=${GOOGLE_PROJECT} \
                        --zone=${GOOGLE_ZONE} \
                        --format='value[separator="
                  "](next,contents)' \
                        > ${console_file}
                    tmp_next=$(head -n 1 ${console_file})
                    if (( tmp_next != console_next )); then
                      console_next=${tmp_next}
                      sed '1d;s/\x1b\[[0-9;]*[JH]//g' ${console_file}
                    fi
                  done
                path: bash
            image: gcloud-image
            task: instance-create
          - get: geode-latest
    - in_parallel:
        fail_fast: true
        steps:
        - config:
            inputs:
            - name: instance
            - name: source
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_upload source .
              path: bash
          image: task-image
          task: upload-source
        - config:
            inputs:
            - name: instance
            - name: geode-latest
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                geode_version=$(cat geode-latest/version)
                geode_name="apache-geode-${geode_version}"
                geode_artifact="${geode_name}.tgz"
                remote_upload geode-latest/${geode_artifact} .
                remote_shell cmake -E tar xvf ${geode_artifact}
                remote_shell cmake -E rename ${geode_name} geode
              path: bash
          image: task-image
          task: upload-geode
    - config:
        inputs:
        - name: instance
        - name: version
        - name: source
        outputs:
        - name: package
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            pushd source
            git_url=$(git remote get-url origin)
            git_rev=$(git rev-parse HEAD)
            popd
            version=$(cat version/number)
            builddate=$(date "+%Y-%m-%d")
            remote_shell cmake -E make_directory build
            remote_shell cmake -E time cmake -E chdir build cmake ../source ${CMAKE_CONFIGURE_FLAGS} \
                -DCMAKE_BUILD_TYPE=${CMAKE_CONFIG} \
                -DGEODE_ROOT=../geode \
                -DPRODUCT_VERSION=${version} \
                -DPRODUCT_BUILDDATE=${builddate} \
                -DPRODUCT_SOURCE_REVISION=${git_rev} \
                -DPRODUCT_SOURCE_REPOSITORY=${git_url}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} --target docs -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake -E chdir build cpack -C ${CMAKE_CONFIG} -G "${CPACK_GENERATORS}" | tee cpack.out
            packages=$(awk '/^CPack: - package: / {print $4}' cpack.out)
            for package in ${packages}; do
              remote_download ${package} package/
            done
            checksums=$(awk '/^CPack: - checksum file: / {print $5}' cpack.out)
            for checksum in ${checksums}; do
              remote_download ${checksum} package/
            done
          path: bash
      image: task-image
      task: build
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration/test ctest -C ${CMAKE_CONFIG} -j4 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/clicache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: net-unmanaged-unit-tests
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/clicache/test2 ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: net-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/clicache/integration-test2 ctest -C ${CMAKE_CONFIG} -j6 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: net-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/clicache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: net-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=Debug --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-integration-test
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-session-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-session-integration-test
      timeout: 10m
    ensure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                GOOGLE_PROJECT=apachegeode-ci
                GOOGLE_ZONE=us-central1-a
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                instance_name=$(source ${instance_file} && echo -n ${name})

                gcloud compute instances delete ${instance_name} \
                    --project=${GOOGLE_PROJECT} \
                    --zone=${GOOGLE_ZONE} \
                    --delete-disks=all \
                    --quiet
              path: bash
          image: gcloud-image
          task: instance-delete
    on_failure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            outputs:
            - name: build
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_download_directory build .
              path: bash
          image: task-image
          task: download-build
  - in_parallel:
      fail_fast: true
      steps:
      - params:
          file: package/*-Windows-64bit.zip
        put: package-windows-2019-vs-2019-debug-archive
      - params:
          file: package/*-Windows-64bit.zip.sha512
        put: package-windows-2019-vs-2019-debug-archive.sha512
  public: true
- name: build-windows-2019-vs-2019-release
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: version
        passed:
        - version-source
        trigger: true
      - get: source
        passed:
        - version-source
        trigger: true
      - get: task-image
  - do:
    - do:
      - in_parallel:
          fail_fast: true
          steps:
          - get: gcloud-image
          - get: geode-native-develop-build-windows-2019-vs-2019-gci
      - in_parallel:
          fail_fast: true
          steps:
          - config:
              inputs:
              - name: geode-native-develop-build-windows-2019-vs-2019-gci
                path: image
              outputs:
              - name: instance
              platform: linux
              run:
                args:
                - -c
                - |-
                  set -ueo pipefail
                  GOOGLE_PROJECT=apachegeode-ci
                  GOOGLE_ZONE=us-central1-a
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi
                  ssh_key_file=${INSTANCE_DIR}/identity
                  ssh_pubkey_file=${ssh_key_file}.pub
                  ssh-keygen -m pem  -t rsa -f ${ssh_key_file} -C "${INSTANCE_USER}" -N '' <<< y
                  ssh_pubkey=$(cat ${ssh_pubkey_file})
                  ssh_keys_file=${INSTANCE_DIR}/ssh_keys_file
                  echo "${INSTANCE_USER}:${ssh_pubkey}" > ${ssh_keys_file}
                  instance_name=build-$(cat /proc/sys/kernel/random/uuid)
                  image_name=$(cat image/name)
                  time_to_live=$(( $(date +%s) + ( 4 * 60 * 60 ) ))
                  instance_file=${INSTANCE_DIR}/instance.sh
                  gcloud compute instances create ${instance_name} \
                      --format='config[export](name,networkInterfaces[0].accessConfigs[0].natIP)' \
                      --project=${GOOGLE_PROJECT} \
                      --zone=${GOOGLE_ZONE} \
                      --subnet=default \
                      --machine-type=e2-standard-16 \
                      --boot-disk-size=200GB \
                      --boot-disk-type=pd-standard \
                      --boot-disk-device-name=${instance_name} \
                      --image-project=${GOOGLE_PROJECT} \
                      --image=${image_name} \
                      --metadata-from-file ssh-keys=${ssh_keys_file} \
                      --labels=time-to-live=${time_to_live},pipeline-name=geode-native-develop,build-config=release \
                      > ${instance_file}
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi

                  SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                  ssh_key_file=${INSTANCE_DIR}/identity
                  if [ ! -r "${ssh_key_file}" ]; then
                    echo "${ssh_key_file} not readable."
                    exit 1
                  fi

                  instance_file=${INSTANCE_DIR}/instance.sh
                  if [ ! -r "${instance_file}" ]; then
                    echo "${instance_file} not readable."
                    exit 1
                  fi

                  external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                  function remote_shell {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                  }

                  function remote_download {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                  }

                  function remote_download_directory {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                  }

                  function remote_upload {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                  }
                  SSH_OPTIONS="${SSH_OPTIONS} -o ConnectTimeout=10"
                  echo "Waiting for ssh on ${instance_name} to be ready."
                  console_file=$(mktemp)
                  console_next=0
                  while ! remote_shell echo ready 2>/dev/null ; do
                    gcloud compute instances get-serial-port-output ${instance_name} \
                        --start ${console_next} \
                        --project=${GOOGLE_PROJECT} \
                        --zone=${GOOGLE_ZONE} \
                        --format='value[separator="
                  "](next,contents)' \
                        > ${console_file}
                    tmp_next=$(head -n 1 ${console_file})
                    if (( tmp_next != console_next )); then
                      console_next=${tmp_next}
                      sed '1d;s/\x1b\[[0-9;]*[JH]//g' ${console_file}
                    fi
                  done
                path: bash
            image: gcloud-image
            task: instance-create
          - get: geode-latest
    - in_parallel:
        fail_fast: true
        steps:
        - config:
            inputs:
            - name: instance
            - name: source
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_upload source .
              path: bash
          image: task-image
          task: upload-source
        - config:
            inputs:
            - name: instance
            - name: geode-latest
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                geode_version=$(cat geode-latest/version)
                geode_name="apache-geode-${geode_version}"
                geode_artifact="${geode_name}.tgz"
                remote_upload geode-latest/${geode_artifact} .
                remote_shell cmake -E tar xvf ${geode_artifact}
                remote_shell cmake -E rename ${geode_name} geode
              path: bash
          image: task-image
          task: upload-geode
    - config:
        inputs:
        - name: instance
        - name: version
        - name: source
        outputs:
        - name: package
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            pushd source
            git_url=$(git remote get-url origin)
            git_rev=$(git rev-parse HEAD)
            popd
            version=$(cat version/number)
            builddate=$(date "+%Y-%m-%d")
            remote_shell cmake -E make_directory build
            remote_shell cmake -E time cmake -E chdir build cmake ../source ${CMAKE_CONFIGURE_FLAGS} \
                -DCMAKE_BUILD_TYPE=${CMAKE_CONFIG} \
                -DGEODE_ROOT=../geode \
                -DPRODUCT_VERSION=${version} \
                -DPRODUCT_BUILDDATE=${builddate} \
                -DPRODUCT_SOURCE_REVISION=${git_rev} \
                -DPRODUCT_SOURCE_REPOSITORY=${git_url}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} --target docs -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake -E chdir build cpack -C ${CMAKE_CONFIG} -G "${CPACK_GENERATORS}" | tee cpack.out
            packages=$(awk '/^CPack: - package: / {print $4}' cpack.out)
            for package in ${packages}; do
              remote_download ${package} package/
            done
            checksums=$(awk '/^CPack: - checksum file: / {print $5}' cpack.out)
            for checksum in ${checksums}; do
              remote_download ${checksum} package/
            done
          path: bash
      image: task-image
      task: build
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration/test ctest -C ${CMAKE_CONFIG} -j4 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/clicache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: net-unmanaged-unit-tests
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/clicache/test2 ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: net-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/clicache/integration-test2 ctest -C ${CMAKE_CONFIG} -j6 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: net-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/clicache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: net-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=RelWithDebInfo --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-integration-test
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: /m
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -A x64 -Tv141,version=14.16,host=x64 -DCMAKE_SYSTEM_VERSION=10.0.16299.0
          CPACK_GENERATORS: ZIP
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-session-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-session-integration-test
      timeout: 10m
    ensure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                GOOGLE_PROJECT=apachegeode-ci
                GOOGLE_ZONE=us-central1-a
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                instance_name=$(source ${instance_file} && echo -n ${name})

                gcloud compute instances delete ${instance_name} \
                    --project=${GOOGLE_PROJECT} \
                    --zone=${GOOGLE_ZONE} \
                    --delete-disks=all \
                    --quiet
              path: bash
          image: gcloud-image
          task: instance-delete
    on_failure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            outputs:
            - name: build
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_download_directory build .
              path: bash
          image: task-image
          task: download-build
  - in_parallel:
      fail_fast: true
      steps:
      - params:
          file: package/*-Windows-64bit.zip
        put: package-windows-2019-vs-2019-release-archive
      - params:
          file: package/*-Windows-64bit.zip.sha512
        put: package-windows-2019-vs-2019-release-archive.sha512
  public: true
- name: build-rhel-7-debug
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: version
        passed:
        - version-source
        trigger: true
      - get: source
        passed:
        - version-source
        trigger: true
      - get: task-image
  - do:
    - do:
      - in_parallel:
          fail_fast: true
          steps:
          - get: gcloud-image
          - get: geode-native-develop-build-rhel-7-gci
      - in_parallel:
          fail_fast: true
          steps:
          - config:
              inputs:
              - name: geode-native-develop-build-rhel-7-gci
                path: image
              outputs:
              - name: instance
              platform: linux
              run:
                args:
                - -c
                - |-
                  set -ueo pipefail
                  GOOGLE_PROJECT=apachegeode-ci
                  GOOGLE_ZONE=us-central1-a
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi
                  ssh_key_file=${INSTANCE_DIR}/identity
                  ssh_pubkey_file=${ssh_key_file}.pub
                  ssh-keygen -m pem  -t rsa -f ${ssh_key_file} -C "${INSTANCE_USER}" -N '' <<< y
                  ssh_pubkey=$(cat ${ssh_pubkey_file})
                  ssh_keys_file=${INSTANCE_DIR}/ssh_keys_file
                  echo "${INSTANCE_USER}:${ssh_pubkey}" > ${ssh_keys_file}
                  instance_name=build-$(cat /proc/sys/kernel/random/uuid)
                  image_name=$(cat image/name)
                  time_to_live=$(( $(date +%s) + ( 4 * 60 * 60 ) ))
                  instance_file=${INSTANCE_DIR}/instance.sh
                  gcloud compute instances create ${instance_name} \
                      --format='config[export](name,networkInterfaces[0].accessConfigs[0].natIP)' \
                      --project=${GOOGLE_PROJECT} \
                      --zone=${GOOGLE_ZONE} \
                      --subnet=default \
                      --machine-type=e2-standard-16 \
                      --boot-disk-size=200GB \
                      --boot-disk-type=pd-standard \
                      --boot-disk-device-name=${instance_name} \
                      --image-project=${GOOGLE_PROJECT} \
                      --image=${image_name} \
                      --metadata-from-file ssh-keys=${ssh_keys_file} \
                      --labels=time-to-live=${time_to_live},pipeline-name=geode-native-develop,build-config=debug \
                      > ${instance_file}
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi

                  SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                  ssh_key_file=${INSTANCE_DIR}/identity
                  if [ ! -r "${ssh_key_file}" ]; then
                    echo "${ssh_key_file} not readable."
                    exit 1
                  fi

                  instance_file=${INSTANCE_DIR}/instance.sh
                  if [ ! -r "${instance_file}" ]; then
                    echo "${instance_file} not readable."
                    exit 1
                  fi

                  external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                  function remote_shell {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                  }

                  function remote_download {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                  }

                  function remote_download_directory {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                  }

                  function remote_upload {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                  }
                  SSH_OPTIONS="${SSH_OPTIONS} -o ConnectTimeout=10"
                  echo "Waiting for ssh on ${instance_name} to be ready."
                  console_file=$(mktemp)
                  console_next=0
                  while ! remote_shell echo ready 2>/dev/null ; do
                    gcloud compute instances get-serial-port-output ${instance_name} \
                        --start ${console_next} \
                        --project=${GOOGLE_PROJECT} \
                        --zone=${GOOGLE_ZONE} \
                        --format='value[separator="
                  "](next,contents)' \
                        > ${console_file}
                    tmp_next=$(head -n 1 ${console_file})
                    if (( tmp_next != console_next )); then
                      console_next=${tmp_next}
                      sed '1d;s/\x1b\[[0-9;]*[JH]//g' ${console_file}
                    fi
                  done
                path: bash
            image: gcloud-image
            task: instance-create
          - get: geode-latest
    - in_parallel:
        fail_fast: true
        steps:
        - config:
            inputs:
            - name: instance
            - name: source
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_upload source .
              path: bash
          image: task-image
          task: upload-source
        - config:
            inputs:
            - name: instance
            - name: geode-latest
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                geode_version=$(cat geode-latest/version)
                geode_name="apache-geode-${geode_version}"
                geode_artifact="${geode_name}.tgz"
                remote_upload geode-latest/${geode_artifact} .
                remote_shell cmake -E tar xvf ${geode_artifact}
                remote_shell cmake -E rename ${geode_name} geode
              path: bash
          image: task-image
          task: upload-geode
    - config:
        inputs:
        - name: instance
        - name: version
        - name: source
        outputs:
        - name: package
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            pushd source
            git_url=$(git remote get-url origin)
            git_rev=$(git rev-parse HEAD)
            popd
            version=$(cat version/number)
            builddate=$(date "+%Y-%m-%d")
            remote_shell cmake -E make_directory build
            remote_shell cmake -E time cmake -E chdir build cmake ../source ${CMAKE_CONFIGURE_FLAGS} \
                -DCMAKE_BUILD_TYPE=${CMAKE_CONFIG} \
                -DGEODE_ROOT=../geode \
                -DPRODUCT_VERSION=${version} \
                -DPRODUCT_BUILDDATE=${builddate} \
                -DPRODUCT_SOURCE_REVISION=${git_rev} \
                -DPRODUCT_SOURCE_REPOSITORY=${git_url}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} --target docs -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake -E chdir build cpack -C ${CMAKE_CONFIG} -G "${CPACK_GENERATORS}" | tee cpack.out
            packages=$(awk '/^CPack: - package: / {print $4}' cpack.out)
            for package in ${packages}; do
              remote_download ${package} package/
            done
            checksums=$(awk '/^CPack: - checksum file: / {print $5}' cpack.out)
            for checksum in ${checksums}; do
              remote_download ${checksum} package/
            done
          path: bash
      image: task-image
      task: build
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration/test ctest -C ${CMAKE_CONFIG} -j4 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=Debug --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-integration-test
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-session-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-session-integration-test
      timeout: 10m
    ensure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                GOOGLE_PROJECT=apachegeode-ci
                GOOGLE_ZONE=us-central1-a
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                instance_name=$(source ${instance_file} && echo -n ${name})

                gcloud compute instances delete ${instance_name} \
                    --project=${GOOGLE_PROJECT} \
                    --zone=${GOOGLE_ZONE} \
                    --delete-disks=all \
                    --quiet
              path: bash
          image: gcloud-image
          task: instance-delete
    on_failure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            outputs:
            - name: build
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_download_directory build .
              path: bash
          image: task-image
          task: download-build
  - in_parallel:
      fail_fast: true
      steps:
      - params:
          file: package/*-Linux-64bit.tar.gz
        put: package-rhel-7-debug-archive
      - params:
          file: package/*-Linux-64bit.tar.gz.sha512
        put: package-rhel-7-debug-archive.sha512
  public: true
- name: build-rhel-7-release
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: version
        passed:
        - version-source
        trigger: true
      - get: source
        passed:
        - version-source
        trigger: true
      - get: task-image
  - do:
    - do:
      - in_parallel:
          fail_fast: true
          steps:
          - get: gcloud-image
          - get: geode-native-develop-build-rhel-7-gci
      - in_parallel:
          fail_fast: true
          steps:
          - config:
              inputs:
              - name: geode-native-develop-build-rhel-7-gci
                path: image
              outputs:
              - name: instance
              platform: linux
              run:
                args:
                - -c
                - |-
                  set -ueo pipefail
                  GOOGLE_PROJECT=apachegeode-ci
                  GOOGLE_ZONE=us-central1-a
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi
                  ssh_key_file=${INSTANCE_DIR}/identity
                  ssh_pubkey_file=${ssh_key_file}.pub
                  ssh-keygen -m pem  -t rsa -f ${ssh_key_file} -C "${INSTANCE_USER}" -N '' <<< y
                  ssh_pubkey=$(cat ${ssh_pubkey_file})
                  ssh_keys_file=${INSTANCE_DIR}/ssh_keys_file
                  echo "${INSTANCE_USER}:${ssh_pubkey}" > ${ssh_keys_file}
                  instance_name=build-$(cat /proc/sys/kernel/random/uuid)
                  image_name=$(cat image/name)
                  time_to_live=$(( $(date +%s) + ( 4 * 60 * 60 ) ))
                  instance_file=${INSTANCE_DIR}/instance.sh
                  gcloud compute instances create ${instance_name} \
                      --format='config[export](name,networkInterfaces[0].accessConfigs[0].natIP)' \
                      --project=${GOOGLE_PROJECT} \
                      --zone=${GOOGLE_ZONE} \
                      --subnet=default \
                      --machine-type=e2-standard-16 \
                      --boot-disk-size=200GB \
                      --boot-disk-type=pd-standard \
                      --boot-disk-device-name=${instance_name} \
                      --image-project=${GOOGLE_PROJECT} \
                      --image=${image_name} \
                      --metadata-from-file ssh-keys=${ssh_keys_file} \
                      --labels=time-to-live=${time_to_live},pipeline-name=geode-native-develop,build-config=release \
                      > ${instance_file}
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi

                  SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                  ssh_key_file=${INSTANCE_DIR}/identity
                  if [ ! -r "${ssh_key_file}" ]; then
                    echo "${ssh_key_file} not readable."
                    exit 1
                  fi

                  instance_file=${INSTANCE_DIR}/instance.sh
                  if [ ! -r "${instance_file}" ]; then
                    echo "${instance_file} not readable."
                    exit 1
                  fi

                  external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                  function remote_shell {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                  }

                  function remote_download {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                  }

                  function remote_download_directory {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                  }

                  function remote_upload {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                  }
                  SSH_OPTIONS="${SSH_OPTIONS} -o ConnectTimeout=10"
                  echo "Waiting for ssh on ${instance_name} to be ready."
                  console_file=$(mktemp)
                  console_next=0
                  while ! remote_shell echo ready 2>/dev/null ; do
                    gcloud compute instances get-serial-port-output ${instance_name} \
                        --start ${console_next} \
                        --project=${GOOGLE_PROJECT} \
                        --zone=${GOOGLE_ZONE} \
                        --format='value[separator="
                  "](next,contents)' \
                        > ${console_file}
                    tmp_next=$(head -n 1 ${console_file})
                    if (( tmp_next != console_next )); then
                      console_next=${tmp_next}
                      sed '1d;s/\x1b\[[0-9;]*[JH]//g' ${console_file}
                    fi
                  done
                path: bash
            image: gcloud-image
            task: instance-create
          - get: geode-latest
    - in_parallel:
        fail_fast: true
        steps:
        - config:
            inputs:
            - name: instance
            - name: source
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_upload source .
              path: bash
          image: task-image
          task: upload-source
        - config:
            inputs:
            - name: instance
            - name: geode-latest
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                geode_version=$(cat geode-latest/version)
                geode_name="apache-geode-${geode_version}"
                geode_artifact="${geode_name}.tgz"
                remote_upload geode-latest/${geode_artifact} .
                remote_shell cmake -E tar xvf ${geode_artifact}
                remote_shell cmake -E rename ${geode_name} geode
              path: bash
          image: task-image
          task: upload-geode
    - config:
        inputs:
        - name: instance
        - name: version
        - name: source
        outputs:
        - name: package
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            pushd source
            git_url=$(git remote get-url origin)
            git_rev=$(git rev-parse HEAD)
            popd
            version=$(cat version/number)
            builddate=$(date "+%Y-%m-%d")
            remote_shell cmake -E make_directory build
            remote_shell cmake -E time cmake -E chdir build cmake ../source ${CMAKE_CONFIGURE_FLAGS} \
                -DCMAKE_BUILD_TYPE=${CMAKE_CONFIG} \
                -DGEODE_ROOT=../geode \
                -DPRODUCT_VERSION=${version} \
                -DPRODUCT_BUILDDATE=${builddate} \
                -DPRODUCT_SOURCE_REVISION=${git_rev} \
                -DPRODUCT_SOURCE_REPOSITORY=${git_url}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} --target docs -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake -E chdir build cpack -C ${CMAKE_CONFIG} -G "${CPACK_GENERATORS}" | tee cpack.out
            packages=$(awk '/^CPack: - package: / {print $4}' cpack.out)
            for package in ${packages}; do
              remote_download ${package} package/
            done
            checksums=$(awk '/^CPack: - checksum file: / {print $5}' cpack.out)
            for checksum in ${checksums}; do
              remote_download ${checksum} package/
            done
          path: bash
      image: task-image
      task: build
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration/test ctest -C ${CMAKE_CONFIG} -j4 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=RelWithDebInfo --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-integration-test
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-session-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-session-integration-test
      timeout: 10m
    ensure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                GOOGLE_PROJECT=apachegeode-ci
                GOOGLE_ZONE=us-central1-a
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                instance_name=$(source ${instance_file} && echo -n ${name})

                gcloud compute instances delete ${instance_name} \
                    --project=${GOOGLE_PROJECT} \
                    --zone=${GOOGLE_ZONE} \
                    --delete-disks=all \
                    --quiet
              path: bash
          image: gcloud-image
          task: instance-delete
    on_failure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            outputs:
            - name: build
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_download_directory build .
              path: bash
          image: task-image
          task: download-build
  - in_parallel:
      fail_fast: true
      steps:
      - params:
          file: package/*-Linux-64bit.tar.gz
        put: package-rhel-7-release-archive
      - params:
          file: package/*-Linux-64bit.tar.gz.sha512
        put: package-rhel-7-release-archive.sha512
  public: true
- name: build-rhel-8-debug
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: version
        passed:
        - version-source
        trigger: true
      - get: source
        passed:
        - version-source
        trigger: true
      - get: task-image
  - do:
    - do:
      - in_parallel:
          fail_fast: true
          steps:
          - get: gcloud-image
          - get: geode-native-develop-build-rhel-8-gci
      - in_parallel:
          fail_fast: true
          steps:
          - config:
              inputs:
              - name: geode-native-develop-build-rhel-8-gci
                path: image
              outputs:
              - name: instance
              platform: linux
              run:
                args:
                - -c
                - |-
                  set -ueo pipefail
                  GOOGLE_PROJECT=apachegeode-ci
                  GOOGLE_ZONE=us-central1-a
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi
                  ssh_key_file=${INSTANCE_DIR}/identity
                  ssh_pubkey_file=${ssh_key_file}.pub
                  ssh-keygen -m pem  -t rsa -f ${ssh_key_file} -C "${INSTANCE_USER}" -N '' <<< y
                  ssh_pubkey=$(cat ${ssh_pubkey_file})
                  ssh_keys_file=${INSTANCE_DIR}/ssh_keys_file
                  echo "${INSTANCE_USER}:${ssh_pubkey}" > ${ssh_keys_file}
                  instance_name=build-$(cat /proc/sys/kernel/random/uuid)
                  image_name=$(cat image/name)
                  time_to_live=$(( $(date +%s) + ( 4 * 60 * 60 ) ))
                  instance_file=${INSTANCE_DIR}/instance.sh
                  gcloud compute instances create ${instance_name} \
                      --format='config[export](name,networkInterfaces[0].accessConfigs[0].natIP)' \
                      --project=${GOOGLE_PROJECT} \
                      --zone=${GOOGLE_ZONE} \
                      --subnet=default \
                      --machine-type=e2-standard-16 \
                      --boot-disk-size=200GB \
                      --boot-disk-type=pd-standard \
                      --boot-disk-device-name=${instance_name} \
                      --image-project=${GOOGLE_PROJECT} \
                      --image=${image_name} \
                      --metadata-from-file ssh-keys=${ssh_keys_file} \
                      --labels=time-to-live=${time_to_live},pipeline-name=geode-native-develop,build-config=debug \
                      > ${instance_file}
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi

                  SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                  ssh_key_file=${INSTANCE_DIR}/identity
                  if [ ! -r "${ssh_key_file}" ]; then
                    echo "${ssh_key_file} not readable."
                    exit 1
                  fi

                  instance_file=${INSTANCE_DIR}/instance.sh
                  if [ ! -r "${instance_file}" ]; then
                    echo "${instance_file} not readable."
                    exit 1
                  fi

                  external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                  function remote_shell {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                  }

                  function remote_download {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                  }

                  function remote_download_directory {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                  }

                  function remote_upload {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                  }
                  SSH_OPTIONS="${SSH_OPTIONS} -o ConnectTimeout=10"
                  echo "Waiting for ssh on ${instance_name} to be ready."
                  console_file=$(mktemp)
                  console_next=0
                  while ! remote_shell echo ready 2>/dev/null ; do
                    gcloud compute instances get-serial-port-output ${instance_name} \
                        --start ${console_next} \
                        --project=${GOOGLE_PROJECT} \
                        --zone=${GOOGLE_ZONE} \
                        --format='value[separator="
                  "](next,contents)' \
                        > ${console_file}
                    tmp_next=$(head -n 1 ${console_file})
                    if (( tmp_next != console_next )); then
                      console_next=${tmp_next}
                      sed '1d;s/\x1b\[[0-9;]*[JH]//g' ${console_file}
                    fi
                  done
                path: bash
            image: gcloud-image
            task: instance-create
          - get: geode-latest
    - in_parallel:
        fail_fast: true
        steps:
        - config:
            inputs:
            - name: instance
            - name: source
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_upload source .
              path: bash
          image: task-image
          task: upload-source
        - config:
            inputs:
            - name: instance
            - name: geode-latest
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                geode_version=$(cat geode-latest/version)
                geode_name="apache-geode-${geode_version}"
                geode_artifact="${geode_name}.tgz"
                remote_upload geode-latest/${geode_artifact} .
                remote_shell cmake -E tar xvf ${geode_artifact}
                remote_shell cmake -E rename ${geode_name} geode
              path: bash
          image: task-image
          task: upload-geode
    - config:
        inputs:
        - name: instance
        - name: version
        - name: source
        outputs:
        - name: package
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -DUSE_IPO=NO
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            pushd source
            git_url=$(git remote get-url origin)
            git_rev=$(git rev-parse HEAD)
            popd
            version=$(cat version/number)
            builddate=$(date "+%Y-%m-%d")
            remote_shell cmake -E make_directory build
            remote_shell cmake -E time cmake -E chdir build cmake ../source ${CMAKE_CONFIGURE_FLAGS} \
                -DCMAKE_BUILD_TYPE=${CMAKE_CONFIG} \
                -DGEODE_ROOT=../geode \
                -DPRODUCT_VERSION=${version} \
                -DPRODUCT_BUILDDATE=${builddate} \
                -DPRODUCT_SOURCE_REVISION=${git_rev} \
                -DPRODUCT_SOURCE_REPOSITORY=${git_url}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} --target docs -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake -E chdir build cpack -C ${CMAKE_CONFIG} -G "${CPACK_GENERATORS}" | tee cpack.out
            packages=$(awk '/^CPack: - package: / {print $4}' cpack.out)
            for package in ${packages}; do
              remote_download ${package} package/
            done
            checksums=$(awk '/^CPack: - checksum file: / {print $5}' cpack.out)
            for checksum in ${checksums}; do
              remote_download ${checksum} package/
            done
          path: bash
      image: task-image
      task: build
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -DUSE_IPO=NO
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -DUSE_IPO=NO
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration/test ctest -C ${CMAKE_CONFIG} -j4 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -DUSE_IPO=NO
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -DUSE_IPO=NO
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=Debug --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-integration-test
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: -DUSE_IPO=NO
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-session-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-session-integration-test
      timeout: 10m
    ensure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                GOOGLE_PROJECT=apachegeode-ci
                GOOGLE_ZONE=us-central1-a
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                instance_name=$(source ${instance_file} && echo -n ${name})

                gcloud compute instances delete ${instance_name} \
                    --project=${GOOGLE_PROJECT} \
                    --zone=${GOOGLE_ZONE} \
                    --delete-disks=all \
                    --quiet
              path: bash
          image: gcloud-image
          task: instance-delete
    on_failure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            outputs:
            - name: build
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_download_directory build .
              path: bash
          image: task-image
          task: download-build
  - in_parallel:
      fail_fast: true
      steps:
      - params:
          file: package/*-Linux-64bit.tar.gz
        put: package-rhel-8-debug-archive
      - params:
          file: package/*-Linux-64bit.tar.gz.sha512
        put: package-rhel-8-debug-archive.sha512
  public: true
- name: build-rhel-8-release
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: version
        passed:
        - version-source
        trigger: true
      - get: source
        passed:
        - version-source
        trigger: true
      - get: task-image
  - do:
    - do:
      - in_parallel:
          fail_fast: true
          steps:
          - get: gcloud-image
          - get: geode-native-develop-build-rhel-8-gci
      - in_parallel:
          fail_fast: true
          steps:
          - config:
              inputs:
              - name: geode-native-develop-build-rhel-8-gci
                path: image
              outputs:
              - name: instance
              platform: linux
              run:
                args:
                - -c
                - |-
                  set -ueo pipefail
                  GOOGLE_PROJECT=apachegeode-ci
                  GOOGLE_ZONE=us-central1-a
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi
                  ssh_key_file=${INSTANCE_DIR}/identity
                  ssh_pubkey_file=${ssh_key_file}.pub
                  ssh-keygen -m pem  -t rsa -f ${ssh_key_file} -C "${INSTANCE_USER}" -N '' <<< y
                  ssh_pubkey=$(cat ${ssh_pubkey_file})
                  ssh_keys_file=${INSTANCE_DIR}/ssh_keys_file
                  echo "${INSTANCE_USER}:${ssh_pubkey}" > ${ssh_keys_file}
                  instance_name=build-$(cat /proc/sys/kernel/random/uuid)
                  image_name=$(cat image/name)
                  time_to_live=$(( $(date +%s) + ( 4 * 60 * 60 ) ))
                  instance_file=${INSTANCE_DIR}/instance.sh
                  gcloud compute instances create ${instance_name} \
                      --format='config[export](name,networkInterfaces[0].accessConfigs[0].natIP)' \
                      --project=${GOOGLE_PROJECT} \
                      --zone=${GOOGLE_ZONE} \
                      --subnet=default \
                      --machine-type=e2-standard-16 \
                      --boot-disk-size=200GB \
                      --boot-disk-type=pd-standard \
                      --boot-disk-device-name=${instance_name} \
                      --image-project=${GOOGLE_PROJECT} \
                      --image=${image_name} \
                      --metadata-from-file ssh-keys=${ssh_keys_file} \
                      --labels=time-to-live=${time_to_live},pipeline-name=geode-native-develop,build-config=release \
                      > ${instance_file}
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi

                  SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                  ssh_key_file=${INSTANCE_DIR}/identity
                  if [ ! -r "${ssh_key_file}" ]; then
                    echo "${ssh_key_file} not readable."
                    exit 1
                  fi

                  instance_file=${INSTANCE_DIR}/instance.sh
                  if [ ! -r "${instance_file}" ]; then
                    echo "${instance_file} not readable."
                    exit 1
                  fi

                  external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                  function remote_shell {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                  }

                  function remote_download {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                  }

                  function remote_download_directory {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                  }

                  function remote_upload {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                  }
                  SSH_OPTIONS="${SSH_OPTIONS} -o ConnectTimeout=10"
                  echo "Waiting for ssh on ${instance_name} to be ready."
                  console_file=$(mktemp)
                  console_next=0
                  while ! remote_shell echo ready 2>/dev/null ; do
                    gcloud compute instances get-serial-port-output ${instance_name} \
                        --start ${console_next} \
                        --project=${GOOGLE_PROJECT} \
                        --zone=${GOOGLE_ZONE} \
                        --format='value[separator="
                  "](next,contents)' \
                        > ${console_file}
                    tmp_next=$(head -n 1 ${console_file})
                    if (( tmp_next != console_next )); then
                      console_next=${tmp_next}
                      sed '1d;s/\x1b\[[0-9;]*[JH]//g' ${console_file}
                    fi
                  done
                path: bash
            image: gcloud-image
            task: instance-create
          - get: geode-latest
    - in_parallel:
        fail_fast: true
        steps:
        - config:
            inputs:
            - name: instance
            - name: source
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_upload source .
              path: bash
          image: task-image
          task: upload-source
        - config:
            inputs:
            - name: instance
            - name: geode-latest
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                geode_version=$(cat geode-latest/version)
                geode_name="apache-geode-${geode_version}"
                geode_artifact="${geode_name}.tgz"
                remote_upload geode-latest/${geode_artifact} .
                remote_shell cmake -E tar xvf ${geode_artifact}
                remote_shell cmake -E rename ${geode_name} geode
              path: bash
          image: task-image
          task: upload-geode
    - config:
        inputs:
        - name: instance
        - name: version
        - name: source
        outputs:
        - name: package
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -DUSE_IPO=NO
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            pushd source
            git_url=$(git remote get-url origin)
            git_rev=$(git rev-parse HEAD)
            popd
            version=$(cat version/number)
            builddate=$(date "+%Y-%m-%d")
            remote_shell cmake -E make_directory build
            remote_shell cmake -E time cmake -E chdir build cmake ../source ${CMAKE_CONFIGURE_FLAGS} \
                -DCMAKE_BUILD_TYPE=${CMAKE_CONFIG} \
                -DGEODE_ROOT=../geode \
                -DPRODUCT_VERSION=${version} \
                -DPRODUCT_BUILDDATE=${builddate} \
                -DPRODUCT_SOURCE_REVISION=${git_rev} \
                -DPRODUCT_SOURCE_REPOSITORY=${git_url}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} --target docs -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake -E chdir build cpack -C ${CMAKE_CONFIG} -G "${CPACK_GENERATORS}" | tee cpack.out
            packages=$(awk '/^CPack: - package: / {print $4}' cpack.out)
            for package in ${packages}; do
              remote_download ${package} package/
            done
            checksums=$(awk '/^CPack: - checksum file: / {print $5}' cpack.out)
            for checksum in ${checksums}; do
              remote_download ${checksum} package/
            done
          path: bash
      image: task-image
      task: build
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -DUSE_IPO=NO
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -DUSE_IPO=NO
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration/test ctest -C ${CMAKE_CONFIG} -j4 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -DUSE_IPO=NO
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -DUSE_IPO=NO
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=RelWithDebInfo --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-integration-test
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: -DUSE_IPO=NO
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-session-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-session-integration-test
      timeout: 10m
    ensure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                GOOGLE_PROJECT=apachegeode-ci
                GOOGLE_ZONE=us-central1-a
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                instance_name=$(source ${instance_file} && echo -n ${name})

                gcloud compute instances delete ${instance_name} \
                    --project=${GOOGLE_PROJECT} \
                    --zone=${GOOGLE_ZONE} \
                    --delete-disks=all \
                    --quiet
              path: bash
          image: gcloud-image
          task: instance-delete
    on_failure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            outputs:
            - name: build
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_download_directory build .
              path: bash
          image: task-image
          task: download-build
  - in_parallel:
      fail_fast: true
      steps:
      - params:
          file: package/*-Linux-64bit.tar.gz
        put: package-rhel-8-release-archive
      - params:
          file: package/*-Linux-64bit.tar.gz.sha512
        put: package-rhel-8-release-archive.sha512
  public: true
- name: build-ubuntu-16.04-debug
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: version
        passed:
        - version-source
        trigger: true
      - get: source
        passed:
        - version-source
        trigger: true
      - get: task-image
  - do:
    - do:
      - in_parallel:
          fail_fast: true
          steps:
          - get: gcloud-image
          - get: geode-native-develop-build-ubuntu-16-04-gci
      - in_parallel:
          fail_fast: true
          steps:
          - config:
              inputs:
              - name: geode-native-develop-build-ubuntu-16-04-gci
                path: image
              outputs:
              - name: instance
              platform: linux
              run:
                args:
                - -c
                - |-
                  set -ueo pipefail
                  GOOGLE_PROJECT=apachegeode-ci
                  GOOGLE_ZONE=us-central1-a
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi
                  ssh_key_file=${INSTANCE_DIR}/identity
                  ssh_pubkey_file=${ssh_key_file}.pub
                  ssh-keygen -m pem  -t rsa -f ${ssh_key_file} -C "${INSTANCE_USER}" -N '' <<< y
                  ssh_pubkey=$(cat ${ssh_pubkey_file})
                  ssh_keys_file=${INSTANCE_DIR}/ssh_keys_file
                  echo "${INSTANCE_USER}:${ssh_pubkey}" > ${ssh_keys_file}
                  instance_name=build-$(cat /proc/sys/kernel/random/uuid)
                  image_name=$(cat image/name)
                  time_to_live=$(( $(date +%s) + ( 4 * 60 * 60 ) ))
                  instance_file=${INSTANCE_DIR}/instance.sh
                  gcloud compute instances create ${instance_name} \
                      --format='config[export](name,networkInterfaces[0].accessConfigs[0].natIP)' \
                      --project=${GOOGLE_PROJECT} \
                      --zone=${GOOGLE_ZONE} \
                      --subnet=default \
                      --machine-type=e2-standard-16 \
                      --boot-disk-size=200GB \
                      --boot-disk-type=pd-standard \
                      --boot-disk-device-name=${instance_name} \
                      --image-project=${GOOGLE_PROJECT} \
                      --image=${image_name} \
                      --metadata-from-file ssh-keys=${ssh_keys_file} \
                      --labels=time-to-live=${time_to_live},pipeline-name=geode-native-develop,build-config=debug \
                      > ${instance_file}
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi

                  SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                  ssh_key_file=${INSTANCE_DIR}/identity
                  if [ ! -r "${ssh_key_file}" ]; then
                    echo "${ssh_key_file} not readable."
                    exit 1
                  fi

                  instance_file=${INSTANCE_DIR}/instance.sh
                  if [ ! -r "${instance_file}" ]; then
                    echo "${instance_file} not readable."
                    exit 1
                  fi

                  external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                  function remote_shell {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                  }

                  function remote_download {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                  }

                  function remote_download_directory {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                  }

                  function remote_upload {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                  }
                  SSH_OPTIONS="${SSH_OPTIONS} -o ConnectTimeout=10"
                  echo "Waiting for ssh on ${instance_name} to be ready."
                  console_file=$(mktemp)
                  console_next=0
                  while ! remote_shell echo ready 2>/dev/null ; do
                    gcloud compute instances get-serial-port-output ${instance_name} \
                        --start ${console_next} \
                        --project=${GOOGLE_PROJECT} \
                        --zone=${GOOGLE_ZONE} \
                        --format='value[separator="
                  "](next,contents)' \
                        > ${console_file}
                    tmp_next=$(head -n 1 ${console_file})
                    if (( tmp_next != console_next )); then
                      console_next=${tmp_next}
                      sed '1d;s/\x1b\[[0-9;]*[JH]//g' ${console_file}
                    fi
                  done
                path: bash
            image: gcloud-image
            task: instance-create
          - get: geode-latest
    - in_parallel:
        fail_fast: true
        steps:
        - config:
            inputs:
            - name: instance
            - name: source
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_upload source .
              path: bash
          image: task-image
          task: upload-source
        - config:
            inputs:
            - name: instance
            - name: geode-latest
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                geode_version=$(cat geode-latest/version)
                geode_name="apache-geode-${geode_version}"
                geode_artifact="${geode_name}.tgz"
                remote_upload geode-latest/${geode_artifact} .
                remote_shell cmake -E tar xvf ${geode_artifact}
                remote_shell cmake -E rename ${geode_name} geode
              path: bash
          image: task-image
          task: upload-geode
    - config:
        inputs:
        - name: instance
        - name: version
        - name: source
        outputs:
        - name: package
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            pushd source
            git_url=$(git remote get-url origin)
            git_rev=$(git rev-parse HEAD)
            popd
            version=$(cat version/number)
            builddate=$(date "+%Y-%m-%d")
            remote_shell cmake -E make_directory build
            remote_shell cmake -E time cmake -E chdir build cmake ../source ${CMAKE_CONFIGURE_FLAGS} \
                -DCMAKE_BUILD_TYPE=${CMAKE_CONFIG} \
                -DGEODE_ROOT=../geode \
                -DPRODUCT_VERSION=${version} \
                -DPRODUCT_BUILDDATE=${builddate} \
                -DPRODUCT_SOURCE_REVISION=${git_rev} \
                -DPRODUCT_SOURCE_REPOSITORY=${git_url}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} --target docs -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake -E chdir build cpack -C ${CMAKE_CONFIG} -G "${CPACK_GENERATORS}" | tee cpack.out
            packages=$(awk '/^CPack: - package: / {print $4}' cpack.out)
            for package in ${packages}; do
              remote_download ${package} package/
            done
            checksums=$(awk '/^CPack: - checksum file: / {print $5}' cpack.out)
            for checksum in ${checksums}; do
              remote_download ${checksum} package/
            done
          path: bash
      image: task-image
      task: build
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration/test ctest -C ${CMAKE_CONFIG} -j4 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=Debug --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-integration-test
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-session-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-session-integration-test
      timeout: 10m
    ensure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                GOOGLE_PROJECT=apachegeode-ci
                GOOGLE_ZONE=us-central1-a
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                instance_name=$(source ${instance_file} && echo -n ${name})

                gcloud compute instances delete ${instance_name} \
                    --project=${GOOGLE_PROJECT} \
                    --zone=${GOOGLE_ZONE} \
                    --delete-disks=all \
                    --quiet
              path: bash
          image: gcloud-image
          task: instance-delete
    on_failure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            outputs:
            - name: build
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_download_directory build .
              path: bash
          image: task-image
          task: download-build
  - in_parallel:
      fail_fast: true
      steps:
      - params:
          file: package/*-Linux-64bit.tar.gz
        put: package-ubuntu-16.04-debug-archive
      - params:
          file: package/*-Linux-64bit.tar.gz.sha512
        put: package-ubuntu-16.04-debug-archive.sha512
  public: true
- name: build-ubuntu-16.04-release
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: version
        passed:
        - version-source
        trigger: true
      - get: source
        passed:
        - version-source
        trigger: true
      - get: task-image
  - do:
    - do:
      - in_parallel:
          fail_fast: true
          steps:
          - get: gcloud-image
          - get: geode-native-develop-build-ubuntu-16-04-gci
      - in_parallel:
          fail_fast: true
          steps:
          - config:
              inputs:
              - name: geode-native-develop-build-ubuntu-16-04-gci
                path: image
              outputs:
              - name: instance
              platform: linux
              run:
                args:
                - -c
                - |-
                  set -ueo pipefail
                  GOOGLE_PROJECT=apachegeode-ci
                  GOOGLE_ZONE=us-central1-a
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi
                  ssh_key_file=${INSTANCE_DIR}/identity
                  ssh_pubkey_file=${ssh_key_file}.pub
                  ssh-keygen -m pem  -t rsa -f ${ssh_key_file} -C "${INSTANCE_USER}" -N '' <<< y
                  ssh_pubkey=$(cat ${ssh_pubkey_file})
                  ssh_keys_file=${INSTANCE_DIR}/ssh_keys_file
                  echo "${INSTANCE_USER}:${ssh_pubkey}" > ${ssh_keys_file}
                  instance_name=build-$(cat /proc/sys/kernel/random/uuid)
                  image_name=$(cat image/name)
                  time_to_live=$(( $(date +%s) + ( 4 * 60 * 60 ) ))
                  instance_file=${INSTANCE_DIR}/instance.sh
                  gcloud compute instances create ${instance_name} \
                      --format='config[export](name,networkInterfaces[0].accessConfigs[0].natIP)' \
                      --project=${GOOGLE_PROJECT} \
                      --zone=${GOOGLE_ZONE} \
                      --subnet=default \
                      --machine-type=e2-standard-16 \
                      --boot-disk-size=200GB \
                      --boot-disk-type=pd-standard \
                      --boot-disk-device-name=${instance_name} \
                      --image-project=${GOOGLE_PROJECT} \
                      --image=${image_name} \
                      --metadata-from-file ssh-keys=${ssh_keys_file} \
                      --labels=time-to-live=${time_to_live},pipeline-name=geode-native-develop,build-config=release \
                      > ${instance_file}
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi

                  SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                  ssh_key_file=${INSTANCE_DIR}/identity
                  if [ ! -r "${ssh_key_file}" ]; then
                    echo "${ssh_key_file} not readable."
                    exit 1
                  fi

                  instance_file=${INSTANCE_DIR}/instance.sh
                  if [ ! -r "${instance_file}" ]; then
                    echo "${instance_file} not readable."
                    exit 1
                  fi

                  external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                  function remote_shell {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                  }

                  function remote_download {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                  }

                  function remote_download_directory {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                  }

                  function remote_upload {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                  }
                  SSH_OPTIONS="${SSH_OPTIONS} -o ConnectTimeout=10"
                  echo "Waiting for ssh on ${instance_name} to be ready."
                  console_file=$(mktemp)
                  console_next=0
                  while ! remote_shell echo ready 2>/dev/null ; do
                    gcloud compute instances get-serial-port-output ${instance_name} \
                        --start ${console_next} \
                        --project=${GOOGLE_PROJECT} \
                        --zone=${GOOGLE_ZONE} \
                        --format='value[separator="
                  "](next,contents)' \
                        > ${console_file}
                    tmp_next=$(head -n 1 ${console_file})
                    if (( tmp_next != console_next )); then
                      console_next=${tmp_next}
                      sed '1d;s/\x1b\[[0-9;]*[JH]//g' ${console_file}
                    fi
                  done
                path: bash
            image: gcloud-image
            task: instance-create
          - get: geode-latest
    - in_parallel:
        fail_fast: true
        steps:
        - config:
            inputs:
            - name: instance
            - name: source
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_upload source .
              path: bash
          image: task-image
          task: upload-source
        - config:
            inputs:
            - name: instance
            - name: geode-latest
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                geode_version=$(cat geode-latest/version)
                geode_name="apache-geode-${geode_version}"
                geode_artifact="${geode_name}.tgz"
                remote_upload geode-latest/${geode_artifact} .
                remote_shell cmake -E tar xvf ${geode_artifact}
                remote_shell cmake -E rename ${geode_name} geode
              path: bash
          image: task-image
          task: upload-geode
    - config:
        inputs:
        - name: instance
        - name: version
        - name: source
        outputs:
        - name: package
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            pushd source
            git_url=$(git remote get-url origin)
            git_rev=$(git rev-parse HEAD)
            popd
            version=$(cat version/number)
            builddate=$(date "+%Y-%m-%d")
            remote_shell cmake -E make_directory build
            remote_shell cmake -E time cmake -E chdir build cmake ../source ${CMAKE_CONFIGURE_FLAGS} \
                -DCMAKE_BUILD_TYPE=${CMAKE_CONFIG} \
                -DGEODE_ROOT=../geode \
                -DPRODUCT_VERSION=${version} \
                -DPRODUCT_BUILDDATE=${builddate} \
                -DPRODUCT_SOURCE_REVISION=${git_rev} \
                -DPRODUCT_SOURCE_REPOSITORY=${git_url}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} --target docs -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake -E chdir build cpack -C ${CMAKE_CONFIG} -G "${CPACK_GENERATORS}" | tee cpack.out
            packages=$(awk '/^CPack: - package: / {print $4}' cpack.out)
            for package in ${packages}; do
              remote_download ${package} package/
            done
            checksums=$(awk '/^CPack: - checksum file: / {print $5}' cpack.out)
            for checksum in ${checksums}; do
              remote_download ${checksum} package/
            done
          path: bash
      image: task-image
      task: build
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration/test ctest -C ${CMAKE_CONFIG} -j4 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=RelWithDebInfo --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-integration-test
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-session-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-session-integration-test
      timeout: 10m
    ensure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                GOOGLE_PROJECT=apachegeode-ci
                GOOGLE_ZONE=us-central1-a
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                instance_name=$(source ${instance_file} && echo -n ${name})

                gcloud compute instances delete ${instance_name} \
                    --project=${GOOGLE_PROJECT} \
                    --zone=${GOOGLE_ZONE} \
                    --delete-disks=all \
                    --quiet
              path: bash
          image: gcloud-image
          task: instance-delete
    on_failure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            outputs:
            - name: build
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_download_directory build .
              path: bash
          image: task-image
          task: download-build
  - in_parallel:
      fail_fast: true
      steps:
      - params:
          file: package/*-Linux-64bit.tar.gz
        put: package-ubuntu-16.04-release-archive
      - params:
          file: package/*-Linux-64bit.tar.gz.sha512
        put: package-ubuntu-16.04-release-archive.sha512
  public: true
- name: build-ubuntu-18.04-debug
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: version
        passed:
        - version-source
        trigger: true
      - get: source
        passed:
        - version-source
        trigger: true
      - get: task-image
  - do:
    - do:
      - in_parallel:
          fail_fast: true
          steps:
          - get: gcloud-image
          - get: geode-native-develop-build-ubuntu-18-04-gci
      - in_parallel:
          fail_fast: true
          steps:
          - config:
              inputs:
              - name: geode-native-develop-build-ubuntu-18-04-gci
                path: image
              outputs:
              - name: instance
              platform: linux
              run:
                args:
                - -c
                - |-
                  set -ueo pipefail
                  GOOGLE_PROJECT=apachegeode-ci
                  GOOGLE_ZONE=us-central1-a
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi
                  ssh_key_file=${INSTANCE_DIR}/identity
                  ssh_pubkey_file=${ssh_key_file}.pub
                  ssh-keygen -m pem  -t rsa -f ${ssh_key_file} -C "${INSTANCE_USER}" -N '' <<< y
                  ssh_pubkey=$(cat ${ssh_pubkey_file})
                  ssh_keys_file=${INSTANCE_DIR}/ssh_keys_file
                  echo "${INSTANCE_USER}:${ssh_pubkey}" > ${ssh_keys_file}
                  instance_name=build-$(cat /proc/sys/kernel/random/uuid)
                  image_name=$(cat image/name)
                  time_to_live=$(( $(date +%s) + ( 4 * 60 * 60 ) ))
                  instance_file=${INSTANCE_DIR}/instance.sh
                  gcloud compute instances create ${instance_name} \
                      --format='config[export](name,networkInterfaces[0].accessConfigs[0].natIP)' \
                      --project=${GOOGLE_PROJECT} \
                      --zone=${GOOGLE_ZONE} \
                      --subnet=default \
                      --machine-type=e2-standard-16 \
                      --boot-disk-size=200GB \
                      --boot-disk-type=pd-standard \
                      --boot-disk-device-name=${instance_name} \
                      --image-project=${GOOGLE_PROJECT} \
                      --image=${image_name} \
                      --metadata-from-file ssh-keys=${ssh_keys_file} \
                      --labels=time-to-live=${time_to_live},pipeline-name=geode-native-develop,build-config=debug \
                      > ${instance_file}
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi

                  SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                  ssh_key_file=${INSTANCE_DIR}/identity
                  if [ ! -r "${ssh_key_file}" ]; then
                    echo "${ssh_key_file} not readable."
                    exit 1
                  fi

                  instance_file=${INSTANCE_DIR}/instance.sh
                  if [ ! -r "${instance_file}" ]; then
                    echo "${instance_file} not readable."
                    exit 1
                  fi

                  external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                  function remote_shell {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                  }

                  function remote_download {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                  }

                  function remote_download_directory {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                  }

                  function remote_upload {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                  }
                  SSH_OPTIONS="${SSH_OPTIONS} -o ConnectTimeout=10"
                  echo "Waiting for ssh on ${instance_name} to be ready."
                  console_file=$(mktemp)
                  console_next=0
                  while ! remote_shell echo ready 2>/dev/null ; do
                    gcloud compute instances get-serial-port-output ${instance_name} \
                        --start ${console_next} \
                        --project=${GOOGLE_PROJECT} \
                        --zone=${GOOGLE_ZONE} \
                        --format='value[separator="
                  "](next,contents)' \
                        > ${console_file}
                    tmp_next=$(head -n 1 ${console_file})
                    if (( tmp_next != console_next )); then
                      console_next=${tmp_next}
                      sed '1d;s/\x1b\[[0-9;]*[JH]//g' ${console_file}
                    fi
                  done
                path: bash
            image: gcloud-image
            task: instance-create
          - get: geode-latest
    - in_parallel:
        fail_fast: true
        steps:
        - config:
            inputs:
            - name: instance
            - name: source
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_upload source .
              path: bash
          image: task-image
          task: upload-source
        - config:
            inputs:
            - name: instance
            - name: geode-latest
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                geode_version=$(cat geode-latest/version)
                geode_name="apache-geode-${geode_version}"
                geode_artifact="${geode_name}.tgz"
                remote_upload geode-latest/${geode_artifact} .
                remote_shell cmake -E tar xvf ${geode_artifact}
                remote_shell cmake -E rename ${geode_name} geode
              path: bash
          image: task-image
          task: upload-geode
    - config:
        inputs:
        - name: instance
        - name: version
        - name: source
        outputs:
        - name: package
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            pushd source
            git_url=$(git remote get-url origin)
            git_rev=$(git rev-parse HEAD)
            popd
            version=$(cat version/number)
            builddate=$(date "+%Y-%m-%d")
            remote_shell cmake -E make_directory build
            remote_shell cmake -E time cmake -E chdir build cmake ../source ${CMAKE_CONFIGURE_FLAGS} \
                -DCMAKE_BUILD_TYPE=${CMAKE_CONFIG} \
                -DGEODE_ROOT=../geode \
                -DPRODUCT_VERSION=${version} \
                -DPRODUCT_BUILDDATE=${builddate} \
                -DPRODUCT_SOURCE_REVISION=${git_rev} \
                -DPRODUCT_SOURCE_REPOSITORY=${git_url}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} --target docs -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake -E chdir build cpack -C ${CMAKE_CONFIG} -G "${CPACK_GENERATORS}" | tee cpack.out
            packages=$(awk '/^CPack: - package: / {print $4}' cpack.out)
            for package in ${packages}; do
              remote_download ${package} package/
            done
            checksums=$(awk '/^CPack: - checksum file: / {print $5}' cpack.out)
            for checksum in ${checksums}; do
              remote_download ${checksum} package/
            done
          path: bash
      image: task-image
      task: build
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration/test ctest -C ${CMAKE_CONFIG} -j4 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=Debug --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-integration-test
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-session-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-session-integration-test
      timeout: 10m
    ensure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                GOOGLE_PROJECT=apachegeode-ci
                GOOGLE_ZONE=us-central1-a
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                instance_name=$(source ${instance_file} && echo -n ${name})

                gcloud compute instances delete ${instance_name} \
                    --project=${GOOGLE_PROJECT} \
                    --zone=${GOOGLE_ZONE} \
                    --delete-disks=all \
                    --quiet
              path: bash
          image: gcloud-image
          task: instance-delete
    on_failure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            outputs:
            - name: build
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_download_directory build .
              path: bash
          image: task-image
          task: download-build
  - in_parallel:
      fail_fast: true
      steps:
      - params:
          file: package/*-Linux-64bit.tar.gz
        put: package-ubuntu-18.04-debug-archive
      - params:
          file: package/*-Linux-64bit.tar.gz.sha512
        put: package-ubuntu-18.04-debug-archive.sha512
  public: true
- name: build-ubuntu-18.04-release
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: version
        passed:
        - version-source
        trigger: true
      - get: source
        passed:
        - version-source
        trigger: true
      - get: task-image
  - do:
    - do:
      - in_parallel:
          fail_fast: true
          steps:
          - get: gcloud-image
          - get: geode-native-develop-build-ubuntu-18-04-gci
      - in_parallel:
          fail_fast: true
          steps:
          - config:
              inputs:
              - name: geode-native-develop-build-ubuntu-18-04-gci
                path: image
              outputs:
              - name: instance
              platform: linux
              run:
                args:
                - -c
                - |-
                  set -ueo pipefail
                  GOOGLE_PROJECT=apachegeode-ci
                  GOOGLE_ZONE=us-central1-a
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi
                  ssh_key_file=${INSTANCE_DIR}/identity
                  ssh_pubkey_file=${ssh_key_file}.pub
                  ssh-keygen -m pem  -t rsa -f ${ssh_key_file} -C "${INSTANCE_USER}" -N '' <<< y
                  ssh_pubkey=$(cat ${ssh_pubkey_file})
                  ssh_keys_file=${INSTANCE_DIR}/ssh_keys_file
                  echo "${INSTANCE_USER}:${ssh_pubkey}" > ${ssh_keys_file}
                  instance_name=build-$(cat /proc/sys/kernel/random/uuid)
                  image_name=$(cat image/name)
                  time_to_live=$(( $(date +%s) + ( 4 * 60 * 60 ) ))
                  instance_file=${INSTANCE_DIR}/instance.sh
                  gcloud compute instances create ${instance_name} \
                      --format='config[export](name,networkInterfaces[0].accessConfigs[0].natIP)' \
                      --project=${GOOGLE_PROJECT} \
                      --zone=${GOOGLE_ZONE} \
                      --subnet=default \
                      --machine-type=e2-standard-16 \
                      --boot-disk-size=200GB \
                      --boot-disk-type=pd-standard \
                      --boot-disk-device-name=${instance_name} \
                      --image-project=${GOOGLE_PROJECT} \
                      --image=${image_name} \
                      --metadata-from-file ssh-keys=${ssh_keys_file} \
                      --labels=time-to-live=${time_to_live},pipeline-name=geode-native-develop,build-config=release \
                      > ${instance_file}
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi

                  SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                  ssh_key_file=${INSTANCE_DIR}/identity
                  if [ ! -r "${ssh_key_file}" ]; then
                    echo "${ssh_key_file} not readable."
                    exit 1
                  fi

                  instance_file=${INSTANCE_DIR}/instance.sh
                  if [ ! -r "${instance_file}" ]; then
                    echo "${instance_file} not readable."
                    exit 1
                  fi

                  external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                  function remote_shell {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                  }

                  function remote_download {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                  }

                  function remote_download_directory {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                  }

                  function remote_upload {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                  }
                  SSH_OPTIONS="${SSH_OPTIONS} -o ConnectTimeout=10"
                  echo "Waiting for ssh on ${instance_name} to be ready."
                  console_file=$(mktemp)
                  console_next=0
                  while ! remote_shell echo ready 2>/dev/null ; do
                    gcloud compute instances get-serial-port-output ${instance_name} \
                        --start ${console_next} \
                        --project=${GOOGLE_PROJECT} \
                        --zone=${GOOGLE_ZONE} \
                        --format='value[separator="
                  "](next,contents)' \
                        > ${console_file}
                    tmp_next=$(head -n 1 ${console_file})
                    if (( tmp_next != console_next )); then
                      console_next=${tmp_next}
                      sed '1d;s/\x1b\[[0-9;]*[JH]//g' ${console_file}
                    fi
                  done
                path: bash
            image: gcloud-image
            task: instance-create
          - get: geode-latest
    - in_parallel:
        fail_fast: true
        steps:
        - config:
            inputs:
            - name: instance
            - name: source
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_upload source .
              path: bash
          image: task-image
          task: upload-source
        - config:
            inputs:
            - name: instance
            - name: geode-latest
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                geode_version=$(cat geode-latest/version)
                geode_name="apache-geode-${geode_version}"
                geode_artifact="${geode_name}.tgz"
                remote_upload geode-latest/${geode_artifact} .
                remote_shell cmake -E tar xvf ${geode_artifact}
                remote_shell cmake -E rename ${geode_name} geode
              path: bash
          image: task-image
          task: upload-geode
    - config:
        inputs:
        - name: instance
        - name: version
        - name: source
        outputs:
        - name: package
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            pushd source
            git_url=$(git remote get-url origin)
            git_rev=$(git rev-parse HEAD)
            popd
            version=$(cat version/number)
            builddate=$(date "+%Y-%m-%d")
            remote_shell cmake -E make_directory build
            remote_shell cmake -E time cmake -E chdir build cmake ../source ${CMAKE_CONFIGURE_FLAGS} \
                -DCMAKE_BUILD_TYPE=${CMAKE_CONFIG} \
                -DGEODE_ROOT=../geode \
                -DPRODUCT_VERSION=${version} \
                -DPRODUCT_BUILDDATE=${builddate} \
                -DPRODUCT_SOURCE_REVISION=${git_rev} \
                -DPRODUCT_SOURCE_REPOSITORY=${git_url}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} --target docs -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake -E chdir build cpack -C ${CMAKE_CONFIG} -G "${CPACK_GENERATORS}" | tee cpack.out
            packages=$(awk '/^CPack: - package: / {print $4}' cpack.out)
            for package in ${packages}; do
              remote_download ${package} package/
            done
            checksums=$(awk '/^CPack: - checksum file: / {print $5}' cpack.out)
            for checksum in ${checksums}; do
              remote_download ${checksum} package/
            done
          path: bash
      image: task-image
      task: build
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration/test ctest -C ${CMAKE_CONFIG} -j4 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=RelWithDebInfo --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-integration-test
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-session-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-session-integration-test
      timeout: 10m
    ensure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                GOOGLE_PROJECT=apachegeode-ci
                GOOGLE_ZONE=us-central1-a
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                instance_name=$(source ${instance_file} && echo -n ${name})

                gcloud compute instances delete ${instance_name} \
                    --project=${GOOGLE_PROJECT} \
                    --zone=${GOOGLE_ZONE} \
                    --delete-disks=all \
                    --quiet
              path: bash
          image: gcloud-image
          task: instance-delete
    on_failure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            outputs:
            - name: build
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_download_directory build .
              path: bash
          image: task-image
          task: download-build
  - in_parallel:
      fail_fast: true
      steps:
      - params:
          file: package/*-Linux-64bit.tar.gz
        put: package-ubuntu-18.04-release-archive
      - params:
          file: package/*-Linux-64bit.tar.gz.sha512
        put: package-ubuntu-18.04-release-archive.sha512
  public: true
- name: build-ubuntu-20.04-debug
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: version
        passed:
        - version-source
        trigger: true
      - get: source
        passed:
        - version-source
        trigger: true
      - get: task-image
  - do:
    - do:
      - in_parallel:
          fail_fast: true
          steps:
          - get: gcloud-image
          - get: geode-native-develop-build-ubuntu-20-04-gci
      - in_parallel:
          fail_fast: true
          steps:
          - config:
              inputs:
              - name: geode-native-develop-build-ubuntu-20-04-gci
                path: image
              outputs:
              - name: instance
              platform: linux
              run:
                args:
                - -c
                - |-
                  set -ueo pipefail
                  GOOGLE_PROJECT=apachegeode-ci
                  GOOGLE_ZONE=us-central1-a
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi
                  ssh_key_file=${INSTANCE_DIR}/identity
                  ssh_pubkey_file=${ssh_key_file}.pub
                  ssh-keygen -m pem  -t rsa -f ${ssh_key_file} -C "${INSTANCE_USER}" -N '' <<< y
                  ssh_pubkey=$(cat ${ssh_pubkey_file})
                  ssh_keys_file=${INSTANCE_DIR}/ssh_keys_file
                  echo "${INSTANCE_USER}:${ssh_pubkey}" > ${ssh_keys_file}
                  instance_name=build-$(cat /proc/sys/kernel/random/uuid)
                  image_name=$(cat image/name)
                  time_to_live=$(( $(date +%s) + ( 4 * 60 * 60 ) ))
                  instance_file=${INSTANCE_DIR}/instance.sh
                  gcloud compute instances create ${instance_name} \
                      --format='config[export](name,networkInterfaces[0].accessConfigs[0].natIP)' \
                      --project=${GOOGLE_PROJECT} \
                      --zone=${GOOGLE_ZONE} \
                      --subnet=default \
                      --machine-type=e2-standard-16 \
                      --boot-disk-size=200GB \
                      --boot-disk-type=pd-standard \
                      --boot-disk-device-name=${instance_name} \
                      --image-project=${GOOGLE_PROJECT} \
                      --image=${image_name} \
                      --metadata-from-file ssh-keys=${ssh_keys_file} \
                      --labels=time-to-live=${time_to_live},pipeline-name=geode-native-develop,build-config=debug \
                      > ${instance_file}
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi

                  SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                  ssh_key_file=${INSTANCE_DIR}/identity
                  if [ ! -r "${ssh_key_file}" ]; then
                    echo "${ssh_key_file} not readable."
                    exit 1
                  fi

                  instance_file=${INSTANCE_DIR}/instance.sh
                  if [ ! -r "${instance_file}" ]; then
                    echo "${instance_file} not readable."
                    exit 1
                  fi

                  external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                  function remote_shell {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                  }

                  function remote_download {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                  }

                  function remote_download_directory {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                  }

                  function remote_upload {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                  }
                  SSH_OPTIONS="${SSH_OPTIONS} -o ConnectTimeout=10"
                  echo "Waiting for ssh on ${instance_name} to be ready."
                  console_file=$(mktemp)
                  console_next=0
                  while ! remote_shell echo ready 2>/dev/null ; do
                    gcloud compute instances get-serial-port-output ${instance_name} \
                        --start ${console_next} \
                        --project=${GOOGLE_PROJECT} \
                        --zone=${GOOGLE_ZONE} \
                        --format='value[separator="
                  "](next,contents)' \
                        > ${console_file}
                    tmp_next=$(head -n 1 ${console_file})
                    if (( tmp_next != console_next )); then
                      console_next=${tmp_next}
                      sed '1d;s/\x1b\[[0-9;]*[JH]//g' ${console_file}
                    fi
                  done
                path: bash
            image: gcloud-image
            task: instance-create
          - get: geode-latest
    - in_parallel:
        fail_fast: true
        steps:
        - config:
            inputs:
            - name: instance
            - name: source
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_upload source .
              path: bash
          image: task-image
          task: upload-source
        - config:
            inputs:
            - name: instance
            - name: geode-latest
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                geode_version=$(cat geode-latest/version)
                geode_name="apache-geode-${geode_version}"
                geode_artifact="${geode_name}.tgz"
                remote_upload geode-latest/${geode_artifact} .
                remote_shell cmake -E tar xvf ${geode_artifact}
                remote_shell cmake -E rename ${geode_name} geode
              path: bash
          image: task-image
          task: upload-geode
    - config:
        inputs:
        - name: instance
        - name: version
        - name: source
        outputs:
        - name: package
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            pushd source
            git_url=$(git remote get-url origin)
            git_rev=$(git rev-parse HEAD)
            popd
            version=$(cat version/number)
            builddate=$(date "+%Y-%m-%d")
            remote_shell cmake -E make_directory build
            remote_shell cmake -E time cmake -E chdir build cmake ../source ${CMAKE_CONFIGURE_FLAGS} \
                -DCMAKE_BUILD_TYPE=${CMAKE_CONFIG} \
                -DGEODE_ROOT=../geode \
                -DPRODUCT_VERSION=${version} \
                -DPRODUCT_BUILDDATE=${builddate} \
                -DPRODUCT_SOURCE_REVISION=${git_rev} \
                -DPRODUCT_SOURCE_REPOSITORY=${git_url}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} --target docs -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake -E chdir build cpack -C ${CMAKE_CONFIG} -G "${CPACK_GENERATORS}" | tee cpack.out
            packages=$(awk '/^CPack: - package: / {print $4}' cpack.out)
            for package in ${packages}; do
              remote_download ${package} package/
            done
            checksums=$(awk '/^CPack: - checksum file: / {print $5}' cpack.out)
            for checksum in ${checksums}; do
              remote_download ${checksum} package/
            done
          path: bash
      image: task-image
      task: build
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration/test ctest -C ${CMAKE_CONFIG} -j4 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=Debug --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-integration-test
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: Debug
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-session-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-session-integration-test
      timeout: 10m
    ensure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                GOOGLE_PROJECT=apachegeode-ci
                GOOGLE_ZONE=us-central1-a
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                instance_name=$(source ${instance_file} && echo -n ${name})

                gcloud compute instances delete ${instance_name} \
                    --project=${GOOGLE_PROJECT} \
                    --zone=${GOOGLE_ZONE} \
                    --delete-disks=all \
                    --quiet
              path: bash
          image: gcloud-image
          task: instance-delete
    on_failure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            outputs:
            - name: build
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_download_directory build .
              path: bash
          image: task-image
          task: download-build
  - in_parallel:
      fail_fast: true
      steps:
      - params:
          file: package/*-Linux-64bit.tar.gz
        put: package-ubuntu-20.04-debug-archive
      - params:
          file: package/*-Linux-64bit.tar.gz.sha512
        put: package-ubuntu-20.04-debug-archive.sha512
  public: true
- name: build-ubuntu-20.04-release
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: version
        passed:
        - version-source
        trigger: true
      - get: source
        passed:
        - version-source
        trigger: true
      - get: task-image
  - do:
    - do:
      - in_parallel:
          fail_fast: true
          steps:
          - get: gcloud-image
          - get: geode-native-develop-build-ubuntu-20-04-gci
      - in_parallel:
          fail_fast: true
          steps:
          - config:
              inputs:
              - name: geode-native-develop-build-ubuntu-20-04-gci
                path: image
              outputs:
              - name: instance
              platform: linux
              run:
                args:
                - -c
                - |-
                  set -ueo pipefail
                  GOOGLE_PROJECT=apachegeode-ci
                  GOOGLE_ZONE=us-central1-a
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi
                  ssh_key_file=${INSTANCE_DIR}/identity
                  ssh_pubkey_file=${ssh_key_file}.pub
                  ssh-keygen -m pem  -t rsa -f ${ssh_key_file} -C "${INSTANCE_USER}" -N '' <<< y
                  ssh_pubkey=$(cat ${ssh_pubkey_file})
                  ssh_keys_file=${INSTANCE_DIR}/ssh_keys_file
                  echo "${INSTANCE_USER}:${ssh_pubkey}" > ${ssh_keys_file}
                  instance_name=build-$(cat /proc/sys/kernel/random/uuid)
                  image_name=$(cat image/name)
                  time_to_live=$(( $(date +%s) + ( 4 * 60 * 60 ) ))
                  instance_file=${INSTANCE_DIR}/instance.sh
                  gcloud compute instances create ${instance_name} \
                      --format='config[export](name,networkInterfaces[0].accessConfigs[0].natIP)' \
                      --project=${GOOGLE_PROJECT} \
                      --zone=${GOOGLE_ZONE} \
                      --subnet=default \
                      --machine-type=e2-standard-16 \
                      --boot-disk-size=200GB \
                      --boot-disk-type=pd-standard \
                      --boot-disk-device-name=${instance_name} \
                      --image-project=${GOOGLE_PROJECT} \
                      --image=${image_name} \
                      --metadata-from-file ssh-keys=${ssh_keys_file} \
                      --labels=time-to-live=${time_to_live},pipeline-name=geode-native-develop,build-config=release \
                      > ${instance_file}
                  INSTANCE_USER=build
                  INSTANCE_DIR=$(pwd)/instance

                  if [ ! -d "${INSTANCE_DIR}" ]; then
                    echo "${INSTANCE_DIR} not found."
                    exit 1
                  fi

                  SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                  ssh_key_file=${INSTANCE_DIR}/identity
                  if [ ! -r "${ssh_key_file}" ]; then
                    echo "${ssh_key_file} not readable."
                    exit 1
                  fi

                  instance_file=${INSTANCE_DIR}/instance.sh
                  if [ ! -r "${instance_file}" ]; then
                    echo "${instance_file} not readable."
                    exit 1
                  fi

                  external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                  function remote_shell {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                  }

                  function remote_download {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                  }

                  function remote_download_directory {
                    ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                  }

                  function remote_upload {
                    scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                  }
                  SSH_OPTIONS="${SSH_OPTIONS} -o ConnectTimeout=10"
                  echo "Waiting for ssh on ${instance_name} to be ready."
                  console_file=$(mktemp)
                  console_next=0
                  while ! remote_shell echo ready 2>/dev/null ; do
                    gcloud compute instances get-serial-port-output ${instance_name} \
                        --start ${console_next} \
                        --project=${GOOGLE_PROJECT} \
                        --zone=${GOOGLE_ZONE} \
                        --format='value[separator="
                  "](next,contents)' \
                        > ${console_file}
                    tmp_next=$(head -n 1 ${console_file})
                    if (( tmp_next != console_next )); then
                      console_next=${tmp_next}
                      sed '1d;s/\x1b\[[0-9;]*[JH]//g' ${console_file}
                    fi
                  done
                path: bash
            image: gcloud-image
            task: instance-create
          - get: geode-latest
    - in_parallel:
        fail_fast: true
        steps:
        - config:
            inputs:
            - name: instance
            - name: source
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_upload source .
              path: bash
          image: task-image
          task: upload-source
        - config:
            inputs:
            - name: instance
            - name: geode-latest
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                geode_version=$(cat geode-latest/version)
                geode_name="apache-geode-${geode_version}"
                geode_artifact="${geode_name}.tgz"
                remote_upload geode-latest/${geode_artifact} .
                remote_shell cmake -E tar xvf ${geode_artifact}
                remote_shell cmake -E rename ${geode_name} geode
              path: bash
          image: task-image
          task: upload-geode
    - config:
        inputs:
        - name: instance
        - name: version
        - name: source
        outputs:
        - name: package
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            pushd source
            git_url=$(git remote get-url origin)
            git_rev=$(git rev-parse HEAD)
            popd
            version=$(cat version/number)
            builddate=$(date "+%Y-%m-%d")
            remote_shell cmake -E make_directory build
            remote_shell cmake -E time cmake -E chdir build cmake ../source ${CMAKE_CONFIGURE_FLAGS} \
                -DCMAKE_BUILD_TYPE=${CMAKE_CONFIG} \
                -DGEODE_ROOT=../geode \
                -DPRODUCT_VERSION=${version} \
                -DPRODUCT_BUILDDATE=${builddate} \
                -DPRODUCT_SOURCE_REVISION=${git_rev} \
                -DPRODUCT_SOURCE_REPOSITORY=${git_url}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake --build build --config ${CMAKE_CONFIG} --target docs -- ${CMAKE_BUILD_FLAGS}
            remote_shell cmake -E time cmake -E chdir build cpack -C ${CMAKE_CONFIG} -G "${CPACK_GENERATORS}" | tee cpack.out
            packages=$(awk '/^CPack: - package: / {print $4}' cpack.out)
            for package in ${packages}; do
              remote_download ${package} package/
            done
            checksums=$(awk '/^CPack: - checksum file: / {print $5}' cpack.out)
            for checksum in ${checksums}; do
              remote_download ${checksum} package/
            done
          path: bash
      image: task-image
      task: build
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/test ctest -C ${CMAKE_CONFIG} -j8 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-unit-tests
      timeout: 30m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration/test ctest -C ${CMAKE_CONFIG} -j4 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-integration-tests
      timeout: 1h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/cppcache/integration-test ctest -C ${CMAKE_CONFIG} -j4 --timeout=500 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: cpp-legacy-integration-tests
      timeout: 2h
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=RelWithDebInfo --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-integration-test
      timeout: 10m
    - config:
        inputs:
        - name: instance
        params:
          CMAKE_BUILD_FLAGS: -j16
          CMAKE_CONFIG: RelWithDebInfo
          CMAKE_CONFIGURE_FLAGS: ""
          CPACK_GENERATORS: TGZ
        platform: linux
        run:
          args:
          - -c
          - |-
            set -ueo pipefail
            INSTANCE_USER=build
            INSTANCE_DIR=$(pwd)/instance

            if [ ! -d "${INSTANCE_DIR}" ]; then
              echo "${INSTANCE_DIR} not found."
              exit 1
            fi

            SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

            ssh_key_file=${INSTANCE_DIR}/identity
            if [ ! -r "${ssh_key_file}" ]; then
              echo "${ssh_key_file} not readable."
              exit 1
            fi

            instance_file=${INSTANCE_DIR}/instance.sh
            if [ ! -r "${instance_file}" ]; then
              echo "${instance_file} not readable."
              exit 1
            fi

            external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

            function remote_shell {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
            }

            function remote_download {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
            }

            function remote_download_directory {
              ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
            }

            function remote_upload {
              scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
            }
            remote_shell cmake -E chdir build/netcore/netcore-session-integration-test ctest -C ${CMAKE_CONFIG} -j1 --timeout=300 --output-on-failure --repeat until-pass:4 --schedule-random
          path: bash
      image: task-image
      task: netcore-session-integration-test
      timeout: 10m
    ensure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                GOOGLE_PROJECT=apachegeode-ci
                GOOGLE_ZONE=us-central1-a
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                instance_name=$(source ${instance_file} && echo -n ${name})

                gcloud compute instances delete ${instance_name} \
                    --project=${GOOGLE_PROJECT} \
                    --zone=${GOOGLE_ZONE} \
                    --delete-disks=all \
                    --quiet
              path: bash
          image: gcloud-image
          task: instance-delete
    on_failure:
      in_parallel:
        steps:
        - config:
            inputs:
            - name: instance
            outputs:
            - name: build
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                INSTANCE_USER=build
                INSTANCE_DIR=$(pwd)/instance

                if [ ! -d "${INSTANCE_DIR}" ]; then
                  echo "${INSTANCE_DIR} not found."
                  exit 1
                fi

                SSH_OPTIONS=${SSH_OPTIONS:-"-o StrictHostKeyChecking=no -o PasswordAuthentication=no"}

                ssh_key_file=${INSTANCE_DIR}/identity
                if [ ! -r "${ssh_key_file}" ]; then
                  echo "${ssh_key_file} not readable."
                  exit 1
                fi

                instance_file=${INSTANCE_DIR}/instance.sh
                if [ ! -r "${instance_file}" ]; then
                  echo "${instance_file} not readable."
                  exit 1
                fi

                external_ip=$(source ${instance_file} && echo -n ${networkInterfaces_accessConfigs_natIP})

                function remote_shell {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} "$@"
                }

                function remote_download {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "${INSTANCE_USER}@${external_ip}:${1}" "$2"
                }

                function remote_download_directory {
                  ssh ${SSH_OPTIONS} -i ${ssh_key_file} ${INSTANCE_USER}@${external_ip} tar -C $(dirname ${1}) -czf - $(basename ${1}) | tar -C ${2} -zxf -
                }

                function remote_upload {
                  scp ${SSH_OPTIONS} -i ${ssh_key_file} -q -r "$1" "${INSTANCE_USER}@${external_ip}:${2}"
                }
                remote_download_directory build .
              path: bash
          image: task-image
          task: download-build
  - in_parallel:
      fail_fast: true
      steps:
      - params:
          file: package/*-Linux-64bit.tar.gz
        put: package-ubuntu-20.04-release-archive
      - params:
          file: package/*-Linux-64bit.tar.gz.sha512
        put: package-ubuntu-20.04-release-archive.sha512
  public: true
- name: check-source
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: clang-tools-image
      - get: version
        passed:
        - version-source
        trigger: true
      - get: source
        passed:
        - version-source
        trigger: true
      - do:
        - get: task-image
        - get: geode-latest
        - config:
            caches:
            - path: geode
            inputs:
            - name: geode-latest
            outputs:
            - name: geode
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                if (cmp -s geode-latest/version geode/version); then
                 exit 0
                fi
                geode_version=$(cat geode-latest/version)
                geode_name="apache-geode-${geode_version}"
                geode_artifact="${geode_name}.tgz"
                tar xvf geode-latest/${geode_artifact} --directory=geode --strip-components=1
                unzip -p geode/lib/geode-core-${geode_version}.jar org/apache/geode/internal/GemFireVersion.properties
                cp geode-latest/version geode/version
              path: bash
          image: task-image
          task: extract-geode
  - in_parallel:
      steps:
      - config:
          inputs:
          - name: source
          - name: geode
          outputs:
          - name: build
          platform: linux
          run:
            args:
            - -c
            - |-
              set -ueo pipefail
              export GEODE_HOME=$(pwd)/geode
              log=$(mktemp)
              cd build
              cmake ../source -DCMAKE_EXPORT_COMPILE_COMMANDS=ON >>${log} 2>&1 || (cat ${log}; exit 1)
              cmake --build dependencies --parallel $(nproc) >>${log} 2>&1 || (cat ${log}; exit 1)
              run-clang-tidy -j $(nproc) -quiet
            path: bash
        image: clang-tools-image
        task: clang-tidy
      - config:
          inputs:
          - name: source
          - name: geode
          outputs:
          - name: build
          platform: linux
          run:
            args:
            - -c
            - |-
              set -ueo pipefail
              export GEODE_HOME=$(pwd)/geode
              log=$(mktemp)
              cd build
              cmake ../source -DCMAKE_EXPORT_COMPILE_COMMANDS=ON >>${log} 2>&1 || (cat ${log}; exit 1)
              jq -r '.[].file' compile_commands.json | sort | uniq | grep -v $(pwd) | xargs clang-format --dry-run -Werror
            path: bash
        image: clang-tools-image
        task: clang-format
      - config:
          inputs:
          - name: source
          - name: geode
          outputs:
          - name: build
          platform: linux
          run:
            args:
            - -c
            - |-
              set -ueo pipefail
              export GEODE_HOME=$(pwd)/geode
              log=$(mktemp)
              cd build
              cmake ../source -DUSE_RAT=ON >>${log} 2>&1 || (cat ${log}; exit 1)
              cmake --build . --target rat-check
            path: bash
        image: clang-tools-image
        task: rat-check
  public: true
- name: update-pipeline
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: ytt-image
      - get: ci-source
        trigger: true
  - config:
      inputs:
      - name: ci-source
        path: source
      outputs:
      - name: pipeline
      platform: linux
      run:
        args:
        - --file
        - source/ci/lib
        - --file
        - source/ci/base
        - --file
        - source/ci/release
        - --data-value
        - pipeline.name=geode-native-develop
        - --data-value
        - pipeline.variant=release
        - --data-value
        - github.owner=apache
        - --data-value
        - github.repository=geode-native
        - --data-value
        - repository.branch=develop
        - --data-value
        - google.project=apachegeode-ci
        - --data-value
        - google.zone=us-central1-a
        - --data-value
        - google.storage.bucket=apachegeode-ci-concourse
        - --data-value
        - google.storage.key=geode-native/geode-native-develop
        - --output-files
        - pipeline/
        path: /usr/bin/ytt
    image: ytt-image
    task: ytt
  - file: pipeline/pipeline.yml
    set_pipeline: self
  public: true
  serial: true
- name: version-source
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: version
        params:
          pre: build
      - get: source
        trigger: true
  - params:
      file: version/number
    put: version
- name: docker-task-image
  plan:
  - get: ci-source
    trigger: true
  - params:
      build: ci-source/ci/docker/task
      cache: true
    put: task-image
- name: docker-clang-tools-image
  plan:
  - get: ci-source
    trigger: true
  - params:
      build: ci-source/ci/docker/clang-tools
      cache: true
    put: clang-tools-image
- name: packer-build-windows-2016-vs-2017
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: packer-image
      - get: windows-2016-gci
        trigger: true
      - get: packer-source
        trigger: true
  - attempts: 5
    config:
      inputs:
      - name: packer-source
        path: source
      platform: linux
      run:
        args:
        - -c
        - |-
          set -ueo pipefail
          cd source/packer
          packer build -only=googlecompute \
              -var-file=default.json \
              -var pipeline=geode-native-develop \
              -var version=1.15.0 \
              -var pre=build \
              -var owner=apache \
              -var repository=geode-native \
              -var branch=develop \
              -var image_name_prefix=geode-native-develop-build-windows-2016-vs-2017 \
              -var image_family=geode-native-develop-build-windows-2016-vs-2017 \
              -var googlecompute_project=apachegeode-ci \
              -var googlecompute_zone=us-central1-a \
              build-windows-2016-vs-2017.json
        path: bash
    image: packer-image
    task: packer-build
- name: packer-build-windows-2019-vs-2019
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: packer-image
      - get: windows-2019-gci
        trigger: true
      - get: packer-source
        trigger: true
  - attempts: 5
    config:
      inputs:
      - name: packer-source
        path: source
      platform: linux
      run:
        args:
        - -c
        - |-
          set -ueo pipefail
          cd source/packer
          packer build -only=googlecompute \
              -var-file=default.json \
              -var pipeline=geode-native-develop \
              -var version=1.15.0 \
              -var pre=build \
              -var owner=apache \
              -var repository=geode-native \
              -var branch=develop \
              -var image_name_prefix=geode-native-develop-build-windows-2019-vs-2019 \
              -var image_family=geode-native-develop-build-windows-2019-vs-2019 \
              -var googlecompute_project=apachegeode-ci \
              -var googlecompute_zone=us-central1-a \
              build-windows-2019-vs-2019.json
        path: bash
    image: packer-image
    task: packer-build
- name: packer-build-rhel-7
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: packer-image
      - get: rhel-7-gci
        trigger: true
      - get: packer-source
        trigger: true
  - attempts: 5
    config:
      inputs:
      - name: packer-source
        path: source
      platform: linux
      run:
        args:
        - -c
        - |-
          set -ueo pipefail
          cd source/packer
          packer build -only=googlecompute \
              -var-file=default.json \
              -var pipeline=geode-native-develop \
              -var version=1.15.0 \
              -var pre=build \
              -var owner=apache \
              -var repository=geode-native \
              -var branch=develop \
              -var image_name_prefix=geode-native-develop-build-rhel-7 \
              -var image_family=geode-native-develop-build-rhel-7 \
              -var googlecompute_project=apachegeode-ci \
              -var googlecompute_zone=us-central1-a \
              build-rhel-7.json
        path: bash
    image: packer-image
    task: packer-build
- name: packer-build-rhel-8
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: packer-image
      - get: rhel-8-gci
        trigger: true
      - get: packer-source
        trigger: true
  - attempts: 5
    config:
      inputs:
      - name: packer-source
        path: source
      platform: linux
      run:
        args:
        - -c
        - |-
          set -ueo pipefail
          cd source/packer
          packer build -only=googlecompute \
              -var-file=default.json \
              -var pipeline=geode-native-develop \
              -var version=1.15.0 \
              -var pre=build \
              -var owner=apache \
              -var repository=geode-native \
              -var branch=develop \
              -var image_name_prefix=geode-native-develop-build-rhel-8 \
              -var image_family=geode-native-develop-build-rhel-8 \
              -var googlecompute_project=apachegeode-ci \
              -var googlecompute_zone=us-central1-a \
              build-rhel-8.json
        path: bash
    image: packer-image
    task: packer-build
- name: packer-build-ubuntu-16-04
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: packer-image
      - get: ubuntu-1604-lts-gci
        trigger: true
      - get: packer-source
        trigger: true
  - attempts: 5
    config:
      inputs:
      - name: packer-source
        path: source
      platform: linux
      run:
        args:
        - -c
        - |-
          set -ueo pipefail
          cd source/packer
          packer build -only=googlecompute \
              -var-file=default.json \
              -var pipeline=geode-native-develop \
              -var version=1.15.0 \
              -var pre=build \
              -var owner=apache \
              -var repository=geode-native \
              -var branch=develop \
              -var image_name_prefix=geode-native-develop-build-ubuntu-16-04 \
              -var image_family=geode-native-develop-build-ubuntu-16-04 \
              -var googlecompute_project=apachegeode-ci \
              -var googlecompute_zone=us-central1-a \
              build-ubuntu-16-04.json
        path: bash
    image: packer-image
    task: packer-build
- name: packer-build-ubuntu-18-04
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: packer-image
      - get: ubuntu-1804-lts-gci
        trigger: true
      - get: packer-source
        trigger: true
  - attempts: 5
    config:
      inputs:
      - name: packer-source
        path: source
      platform: linux
      run:
        args:
        - -c
        - |-
          set -ueo pipefail
          cd source/packer
          packer build -only=googlecompute \
              -var-file=default.json \
              -var pipeline=geode-native-develop \
              -var version=1.15.0 \
              -var pre=build \
              -var owner=apache \
              -var repository=geode-native \
              -var branch=develop \
              -var image_name_prefix=geode-native-develop-build-ubuntu-18-04 \
              -var image_family=geode-native-develop-build-ubuntu-18-04 \
              -var googlecompute_project=apachegeode-ci \
              -var googlecompute_zone=us-central1-a \
              build-ubuntu-18-04.json
        path: bash
    image: packer-image
    task: packer-build
- name: packer-build-ubuntu-20-04
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: packer-image
      - get: ubuntu-2004-lts-gci
        trigger: true
      - get: packer-source
        trigger: true
  - attempts: 5
    config:
      inputs:
      - name: packer-source
        path: source
      platform: linux
      run:
        args:
        - -c
        - |-
          set -ueo pipefail
          cd source/packer
          packer build -only=googlecompute \
              -var-file=default.json \
              -var pipeline=geode-native-develop \
              -var version=1.15.0 \
              -var pre=build \
              -var owner=apache \
              -var repository=geode-native \
              -var branch=develop \
              -var image_name_prefix=geode-native-develop-build-ubuntu-20-04 \
              -var image_family=geode-native-develop-build-ubuntu-20-04 \
              -var googlecompute_project=apachegeode-ci \
              -var googlecompute_zone=us-central1-a \
              build-ubuntu-20-04.json
        path: bash
    image: packer-image
    task: packer-build
- name: github-pre-release
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: version
        passed:
        - native-passed
        trigger: true
      - get: source
        passed:
        - native-passed
        trigger: true
      - get: package-windows-2016-vs-2017-debug-archive
        passed:
        - native-passed
        trigger: true
      - get: package-windows-2016-vs-2017-debug-archive.sha512
        passed:
        - native-passed
        trigger: true
      - get: package-windows-2016-vs-2017-release-archive
        passed:
        - native-passed
        trigger: true
      - get: package-windows-2016-vs-2017-release-archive.sha512
        passed:
        - native-passed
        trigger: true
      - get: package-windows-2019-vs-2019-debug-archive
        passed:
        - native-passed
        trigger: true
      - get: package-windows-2019-vs-2019-debug-archive.sha512
        passed:
        - native-passed
        trigger: true
      - get: package-windows-2019-vs-2019-release-archive
        passed:
        - native-passed
        trigger: true
      - get: package-windows-2019-vs-2019-release-archive.sha512
        passed:
        - native-passed
        trigger: true
      - get: package-rhel-7-debug-archive
        passed:
        - native-passed
        trigger: true
      - get: package-rhel-7-debug-archive.sha512
        passed:
        - native-passed
        trigger: true
      - get: package-rhel-7-release-archive
        passed:
        - native-passed
        trigger: true
      - get: package-rhel-7-release-archive.sha512
        passed:
        - native-passed
        trigger: true
      - get: package-rhel-8-debug-archive
        passed:
        - native-passed
        trigger: true
      - get: package-rhel-8-debug-archive.sha512
        passed:
        - native-passed
        trigger: true
      - get: package-rhel-8-release-archive
        passed:
        - native-passed
        trigger: true
      - get: package-rhel-8-release-archive.sha512
        passed:
        - native-passed
        trigger: true
      - get: package-ubuntu-16.04-debug-archive
        passed:
        - native-passed
        trigger: true
      - get: package-ubuntu-16.04-debug-archive.sha512
        passed:
        - native-passed
        trigger: true
      - get: package-ubuntu-16.04-release-archive
        passed:
        - native-passed
        trigger: true
      - get: package-ubuntu-16.04-release-archive.sha512
        passed:
        - native-passed
        trigger: true
      - get: package-ubuntu-18.04-debug-archive
        passed:
        - native-passed
        trigger: true
      - get: package-ubuntu-18.04-debug-archive.sha512
        passed:
        - native-passed
        trigger: true
      - get: package-ubuntu-18.04-release-archive
        passed:
        - native-passed
        trigger: true
      - get: package-ubuntu-18.04-release-archive.sha512
        passed:
        - native-passed
        trigger: true
      - get: package-ubuntu-20.04-debug-archive
        passed:
        - native-passed
        trigger: true
      - get: package-ubuntu-20.04-debug-archive.sha512
        passed:
        - native-passed
        trigger: true
      - get: package-ubuntu-20.04-release-archive
        passed:
        - native-passed
        trigger: true
      - get: package-ubuntu-20.04-release-archive.sha512
        passed:
        - native-passed
        trigger: true
  - params:
      commitish: source/.git/ref
      globs:
      - package-*-release-*/apache-geode-native-*
      name: version/version
      tag: version/version
      tag_prefix: pre-release/v
    put: github-pre-release
- name: bump-minor-version
  plan:
  - params:
      bump: minor
      pre: build
    put: version
- name: native-passed
  plan:
  - in_parallel:
      fail_fast: true
      steps:
      - get: version
        passed:
        - build-windows-2016-vs-2017-debug
        - build-windows-2016-vs-2017-release
        - build-windows-2019-vs-2019-debug
        - build-windows-2019-vs-2019-release
        - build-rhel-7-debug
        - build-rhel-7-release
        - build-rhel-8-debug
        - build-rhel-8-release
        - build-ubuntu-16.04-debug
        - build-ubuntu-16.04-release
        - build-ubuntu-18.04-debug
        - build-ubuntu-18.04-release
        - build-ubuntu-20.04-debug
        - build-ubuntu-20.04-release
        - check-source
        trigger: true
      - get: source
        passed:
        - build-windows-2016-vs-2017-debug
        - build-windows-2016-vs-2017-release
        - build-windows-2019-vs-2019-debug
        - build-windows-2019-vs-2019-release
        - build-rhel-7-debug
        - build-rhel-7-release
        - build-rhel-8-debug
        - build-rhel-8-release
        - build-ubuntu-16.04-debug
        - build-ubuntu-16.04-release
        - build-ubuntu-18.04-debug
        - build-ubuntu-18.04-release
        - build-ubuntu-20.04-debug
        - build-ubuntu-20.04-release
        - check-source
        trigger: true
      - get: package-windows-2016-vs-2017-debug-archive
        passed:
        - build-windows-2016-vs-2017-debug
        trigger: true
      - get: package-windows-2016-vs-2017-debug-archive.sha512
        passed:
        - build-windows-2016-vs-2017-debug
        trigger: true
      - get: package-windows-2016-vs-2017-release-archive
        passed:
        - build-windows-2016-vs-2017-release
        trigger: true
      - get: package-windows-2016-vs-2017-release-archive.sha512
        passed:
        - build-windows-2016-vs-2017-release
        trigger: true
      - get: package-windows-2019-vs-2019-debug-archive
        passed:
        - build-windows-2019-vs-2019-debug
        trigger: true
      - get: package-windows-2019-vs-2019-debug-archive.sha512
        passed:
        - build-windows-2019-vs-2019-debug
        trigger: true
      - get: package-windows-2019-vs-2019-release-archive
        passed:
        - build-windows-2019-vs-2019-release
        trigger: true
      - get: package-windows-2019-vs-2019-release-archive.sha512
        passed:
        - build-windows-2019-vs-2019-release
        trigger: true
      - get: package-rhel-7-debug-archive
        passed:
        - build-rhel-7-debug
        trigger: true
      - get: package-rhel-7-debug-archive.sha512
        passed:
        - build-rhel-7-debug
        trigger: true
      - get: package-rhel-7-release-archive
        passed:
        - build-rhel-7-release
        trigger: true
      - get: package-rhel-7-release-archive.sha512
        passed:
        - build-rhel-7-release
        trigger: true
      - get: package-rhel-8-debug-archive
        passed:
        - build-rhel-8-debug
        trigger: true
      - get: package-rhel-8-debug-archive.sha512
        passed:
        - build-rhel-8-debug
        trigger: true
      - get: package-rhel-8-release-archive
        passed:
        - build-rhel-8-release
        trigger: true
      - get: package-rhel-8-release-archive.sha512
        passed:
        - build-rhel-8-release
        trigger: true
      - get: package-ubuntu-16.04-debug-archive
        passed:
        - build-ubuntu-16.04-debug
        trigger: true
      - get: package-ubuntu-16.04-debug-archive.sha512
        passed:
        - build-ubuntu-16.04-debug
        trigger: true
      - get: package-ubuntu-16.04-release-archive
        passed:
        - build-ubuntu-16.04-release
        trigger: true
      - get: package-ubuntu-16.04-release-archive.sha512
        passed:
        - build-ubuntu-16.04-release
        trigger: true
      - get: package-ubuntu-18.04-debug-archive
        passed:
        - build-ubuntu-18.04-debug
        trigger: true
      - get: package-ubuntu-18.04-debug-archive.sha512
        passed:
        - build-ubuntu-18.04-debug
        trigger: true
      - get: package-ubuntu-18.04-release-archive
        passed:
        - build-ubuntu-18.04-release
        trigger: true
      - get: package-ubuntu-18.04-release-archive.sha512
        passed:
        - build-ubuntu-18.04-release
        trigger: true
      - get: package-ubuntu-20.04-debug-archive
        passed:
        - build-ubuntu-20.04-debug
        trigger: true
      - get: package-ubuntu-20.04-debug-archive.sha512
        passed:
        - build-ubuntu-20.04-debug
        trigger: true
      - get: package-ubuntu-20.04-release-archive
        passed:
        - build-ubuntu-20.04-release
        trigger: true
      - get: package-ubuntu-20.04-release-archive.sha512
        passed:
        - build-ubuntu-20.04-release
        trigger: true
      - do:
        - get: task-image
        - get: geode-latest
        - config:
            caches:
            - path: geode
            inputs:
            - name: geode-latest
            outputs:
            - name: geode
            platform: linux
            run:
              args:
              - -c
              - |-
                set -ueo pipefail
                if (cmp -s geode-latest/version geode/version); then
                 exit 0
                fi
                geode_version=$(cat geode-latest/version)
                geode_name="apache-geode-${geode_version}"
                geode_artifact="${geode_name}.tgz"
                tar xvf geode-latest/${geode_artifact} --directory=geode --strip-components=1
                unzip -p geode/lib/geode-core-${geode_version}.jar org/apache/geode/internal/GemFireVersion.properties
                cp geode-latest/version geode/version
              path: bash
          image: task-image
          task: extract-geode
resource_types:
- name: apache-directory-index-resource
  source:
    repository: jakepivotal/apache-directory-index-resource
  type: docker-image
- name: gci-resource
  source:
    repository: smgoller/gci-resource
  type: docker-image
- name: gcs-resource
  source:
    repository: frodenas/gcs-resource
  type: docker-image
- name: maven-resource
  source:
    repository: jakepivotal/maven-resource
  type: docker-image
resources:
- icon: github
  name: ci-source
  source:
    branch: develop
    depth: 1
    ignore_paths: []
    paths:
    - ci/*
    uri: https://github.com/apache/geode-native.git
  type: git
- icon: docker
  name: clang-tools-image
  source:
    password: ((concourse-gcp-key))
    repository: gcr.io/apachegeode-ci/geode-native-clang-tools
    tag: latest
    username: _json_key
  type: docker-image
- icon: docker
  name: gcloud-image
  source:
    password: ((concourse-gcp-key))
    registry_mirror:
      host: null
    repository: gcr.io/google.com/cloudsdktool/cloud-sdk
    tag: alpine
    username: _json_key
  type: registry-image
- icon: archive
  name: geode-latest
  source:
    artifact: org.apache.geode:apache-geode:tgz
    url: https://maven.apachegeode-ci.info/snapshots
    version: 1\.15\.0-build\..*
  type: maven-resource
- icon: google-cloud
  name: geode-native-develop-build-rhel-7-gci
  source:
    family: geode-native-develop-build-rhel-7
    family_project: apachegeode-ci
    key: ((concourse-gcp-key))
  type: gci-resource
- icon: google-cloud
  name: geode-native-develop-build-rhel-8-gci
  source:
    family: geode-native-develop-build-rhel-8
    family_project: apachegeode-ci
    key: ((concourse-gcp-key))
  type: gci-resource
- icon: google-cloud
  name: geode-native-develop-build-ubuntu-16-04-gci
  source:
    family: geode-native-develop-build-ubuntu-16-04
    family_project: apachegeode-ci
    key: ((concourse-gcp-key))
  type: gci-resource
- icon: google-cloud
  name: geode-native-develop-build-ubuntu-18-04-gci
  source:
    family: geode-native-develop-build-ubuntu-18-04
    family_project: apachegeode-ci
    key: ((concourse-gcp-key))
  type: gci-resource
- icon: google-cloud
  name: geode-native-develop-build-ubuntu-20-04-gci
  source:
    family: geode-native-develop-build-ubuntu-20-04
    family_project: apachegeode-ci
    key: ((concourse-gcp-key))
  type: gci-resource
- icon: google-cloud
  name: geode-native-develop-build-windows-2016-vs-2017-gci
  source:
    family: geode-native-develop-build-windows-2016-vs-2017
    family_project: apachegeode-ci
    key: ((concourse-gcp-key))
  type: gci-resource
- icon: google-cloud
  name: geode-native-develop-build-windows-2019-vs-2019-gci
  source:
    family: geode-native-develop-build-windows-2019-vs-2019
    family_project: apachegeode-ci
    key: ((concourse-gcp-key))
  type: gci-resource
- icon: github
  name: github-pre-release
  source:
    access_token: ((github-pr-access-token))
    owner: apache
    pre_release: true
    release: false
    repository: geode-native
  type: github-release
- icon: content-save
  name: package-rhel-7-debug-archive
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/rhel-7/debug/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz
  type: gcs-resource
- icon: content-save
  name: package-rhel-7-debug-archive.sha512
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/rhel-7/debug/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz.sha512
  type: gcs-resource
- icon: content-save
  name: package-rhel-7-release-archive
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/rhel-7/release/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz
  type: gcs-resource
- icon: content-save
  name: package-rhel-7-release-archive.sha512
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/rhel-7/release/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz.sha512
  type: gcs-resource
- icon: content-save
  name: package-rhel-8-debug-archive
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/rhel-8/debug/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz
  type: gcs-resource
- icon: content-save
  name: package-rhel-8-debug-archive.sha512
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/rhel-8/debug/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz.sha512
  type: gcs-resource
- icon: content-save
  name: package-rhel-8-release-archive
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/rhel-8/release/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz
  type: gcs-resource
- icon: content-save
  name: package-rhel-8-release-archive.sha512
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/rhel-8/release/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz.sha512
  type: gcs-resource
- icon: content-save
  name: package-ubuntu-16.04-debug-archive
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/ubuntu-16.04/debug/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz
  type: gcs-resource
- icon: content-save
  name: package-ubuntu-16.04-debug-archive.sha512
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/ubuntu-16.04/debug/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz.sha512
  type: gcs-resource
- icon: content-save
  name: package-ubuntu-16.04-release-archive
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/ubuntu-16.04/release/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz
  type: gcs-resource
- icon: content-save
  name: package-ubuntu-16.04-release-archive.sha512
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/ubuntu-16.04/release/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz.sha512
  type: gcs-resource
- icon: content-save
  name: package-ubuntu-18.04-debug-archive
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/ubuntu-18.04/debug/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz
  type: gcs-resource
- icon: content-save
  name: package-ubuntu-18.04-debug-archive.sha512
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/ubuntu-18.04/debug/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz.sha512
  type: gcs-resource
- icon: content-save
  name: package-ubuntu-18.04-release-archive
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/ubuntu-18.04/release/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz
  type: gcs-resource
- icon: content-save
  name: package-ubuntu-18.04-release-archive.sha512
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/ubuntu-18.04/release/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz.sha512
  type: gcs-resource
- icon: content-save
  name: package-ubuntu-20.04-debug-archive
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/ubuntu-20.04/debug/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz
  type: gcs-resource
- icon: content-save
  name: package-ubuntu-20.04-debug-archive.sha512
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/ubuntu-20.04/debug/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz.sha512
  type: gcs-resource
- icon: content-save
  name: package-ubuntu-20.04-release-archive
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/ubuntu-20.04/release/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz
  type: gcs-resource
- icon: content-save
  name: package-ubuntu-20.04-release-archive.sha512
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/ubuntu-20.04/release/apache-geode-native-(?P<version>.*)-Linux-64bit.tar.gz.sha512
  type: gcs-resource
- icon: content-save
  name: package-windows-2016-vs-2017-debug-archive
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/windows-2016-vs-2017/debug/apache-geode-native-(?P<version>.*)-Windows-64bit.zip
  type: gcs-resource
- icon: content-save
  name: package-windows-2016-vs-2017-debug-archive.sha512
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/windows-2016-vs-2017/debug/apache-geode-native-(?P<version>.*)-Windows-64bit.zip.sha512
  type: gcs-resource
- icon: content-save
  name: package-windows-2016-vs-2017-release-archive
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/windows-2016-vs-2017/release/apache-geode-native-(?P<version>.*)-Windows-64bit.zip
  type: gcs-resource
- icon: content-save
  name: package-windows-2016-vs-2017-release-archive.sha512
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/windows-2016-vs-2017/release/apache-geode-native-(?P<version>.*)-Windows-64bit.zip.sha512
  type: gcs-resource
- icon: content-save
  name: package-windows-2019-vs-2019-debug-archive
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/windows-2019-vs-2019/debug/apache-geode-native-(?P<version>.*)-Windows-64bit.zip
  type: gcs-resource
- icon: content-save
  name: package-windows-2019-vs-2019-debug-archive.sha512
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/windows-2019-vs-2019/debug/apache-geode-native-(?P<version>.*)-Windows-64bit.zip.sha512
  type: gcs-resource
- icon: content-save
  name: package-windows-2019-vs-2019-release-archive
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/windows-2019-vs-2019/release/apache-geode-native-(?P<version>.*)-Windows-64bit.zip
  type: gcs-resource
- icon: content-save
  name: package-windows-2019-vs-2019-release-archive.sha512
  source:
    bucket: apachegeode-ci-concourse
    json_key: ((concourse-gcp-key))
    regexp: geode-native/geode-native-develop/packages/windows-2019-vs-2019/release/apache-geode-native-(?P<version>.*)-Windows-64bit.zip.sha512
  type: gcs-resource
- icon: docker
  name: packer-image
  source:
    password: null
    registry_mirror:
      host: mirror.gcr.io
    repository: hashicorp/packer
    tag: latest
    username: null
  type: registry-image
- icon: github
  name: packer-source
  source:
    branch: develop
    depth: 1
    ignore_paths: []
    paths:
    - packer/*
    uri: https://github.com/apache/geode-native.git
  type: git
- icon: google-cloud
  name: rhel-7-gci
  source:
    family: rhel-7
    family_project: apachegeode-ci
    key: ((concourse-gcp-key))
  type: gci-resource
- icon: google-cloud
  name: rhel-8-gci
  source:
    family: rhel-8
    family_project: apachegeode-ci
    key: ((concourse-gcp-key))
  type: gci-resource
- icon: github
  name: source
  source:
    branch: develop
    depth: 1
    ignore_paths:
    - ci/*
    - packer/*
    paths: []
    uri: https://github.com/apache/geode-native.git
  type: git
- icon: docker
  name: task-image
  source:
    password: ((concourse-gcp-key))
    repository: gcr.io/apachegeode-ci/geode-native-task
    tag: latest
    username: _json_key
  type: docker-image
- icon: google-cloud
  name: ubuntu-1604-lts-gci
  source:
    family: ubuntu-1604-lts
    family_project: apachegeode-ci
    key: ((concourse-gcp-key))
  type: gci-resource
- icon: google-cloud
  name: ubuntu-1804-lts-gci
  source:
    family: ubuntu-1804-lts
    family_project: apachegeode-ci
    key: ((concourse-gcp-key))
  type: gci-resource
- icon: google-cloud
  name: ubuntu-2004-lts-gci
  source:
    family: ubuntu-2004-lts
    family_project: apachegeode-ci
    key: ((concourse-gcp-key))
  type: gci-resource
- icon: numeric-1-box-multiple
  name: version
  source:
    bucket: apachegeode-ci-concourse
    driver: gcs
    initial_version: 1.15.0-build.0
    json_key: ((concourse-gcp-key))
    key: geode-native/geode-native-develop/version
  type: semver
- icon: google-cloud
  name: windows-2016-gci
  source:
    family: windows-2016
    family_project: apachegeode-ci
    key: ((concourse-gcp-key))
  type: gci-resource
- icon: google-cloud
  name: windows-2019-gci
  source:
    family: windows-2019
    family_project: apachegeode-ci
    key: ((concourse-gcp-key))
  type: gci-resource
- icon: docker
  name: ytt-image
  source:
    password: null
    registry_mirror:
      host: mirror.gcr.io
    repository: gerritk/ytt
    tag: latest
    username: null
  type: registry-image
