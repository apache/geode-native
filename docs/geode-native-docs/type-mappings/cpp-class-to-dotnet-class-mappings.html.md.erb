---
title:  C++ Class to .NET Class Mappings
---

<!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

Wherever the native C++ class methods use pass-by-reference semantics to return data, the corresponding .NET methods shown in the following table return the object instead of using pass-by-reference semantics.

<a id="concept_FD847E19497C4985ACB247C0FA2C2AD5__table_8D8D228E223E4E89A313A17DB5C38652"></a>

<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th><p>C++ Class</p></th>
<th><p>.NET Class</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>class <code class="ph codeph">apache::geode::client::AttributesFactory</code></td>
<td>Sealed class <code class="ph codeph">AttributesFactory</code></td>
</tr>
<tr class="even">
<td><p>class <code class="ph codeph">apache::geode::client::AttributesMutator</code></p></td>
<td>Sealed class <code class="ph codeph">AttributesMutator</code></td>
</tr>
<tr class="odd">
<td>class <code class="ph codeph">apache::geode::client::Cache</code></td>
<td>Sealed class <code class="ph codeph">Cache</code></td>
</tr>
<tr class="even">
<td><p>abstract class <code class="ph codeph">apache::geode::client::Cacheable</code></p></td>
<td><p>Interface <code class="ph codeph">IPdxSerializable</code> or interface <code class="ph codeph">IGeodeSerializable</code></p></td>
</tr>
<tr class="odd">
<td><p>class <code class="ph codeph">apache::geode::client::CacheableBytes</code></p></td>
<td><p><code class="ph codeph">Byte[]</code> or <code class="ph codeph">ArrayList&lt;Byte&gt;</code></p></td>
</tr>
<tr class="even">
<td><p>class <code class="ph codeph">apache::geode::client::Cacheableint32</code></p></td>
<td><p><code class="ph codeph">Int32</code></p></td>
</tr>
<tr class="odd">
<td><p>class <code class="ph codeph">apache::geode::client::CacheableString</code></p></td>
<td><p><code class="ph codeph">String</code></p></td>
</tr>
<tr class="even">
<td><p>abstract class <code class="ph codeph">apache::geode::client::CacheableKey</code></p></td>
<td><p>You can use any type that implements <code class="ph codeph">hashcode</code> and <code class="ph codeph">equals</code>. The generic .NET built-in types are all suitable.</p></td>
</tr>
<tr class="odd">
<td><p>abstract class <code class="ph codeph">apache::geode::client::CacheListener</code></p></td>
<td><p>Interface <code class="ph codeph">ICacheListener</code></p></td>
</tr>
<tr class="even">
<td><p>class <code class="ph codeph">apache::geode::client::CacheLoader</code></p></td>
<td><p>Interface <code class="ph codeph">ICacheLoader</code> plus static class <code class="ph codeph">CacheLoader</code></p></td>
</tr>
<tr class="odd">
<td><p>class <code class="ph codeph">apache::geode::client::CacheWriter</code></p></td>
<td><p>Interface class <code class="ph codeph">ICacheWriter</code></p></td>
</tr>
<tr class="even">
<td><p>class <code class="ph codeph">apache::geode::client::CacheFactory</code></p></td>
<td><p>Sealed class <code class="ph codeph">CacheFactory</code></p></td>
</tr>
<tr class="odd">
<td><p>class <code class="ph codeph">apache::geode::client::DataInput</code></p></td>
<td><p>With <code class="ph codeph">IPdxSerializable</code>, <code class="ph codeph">IPdxReader.</code></p>
<p>With <code class="ph codeph">IGeodeSerializable</code>, sealed class <code class="ph codeph">DataInput</code>.</p></td>
</tr>
<tr class="even">
<td><p>class <code class="ph codeph">apache::geode::client::DataOutput</code></p></td>
<td><p>With <code class="ph codeph">IPdxSerializable</code>, <code class="ph codeph">IPdxWriter.</code></p>
<p>With <code class="ph codeph">IGeodeSerializable</code>, sealed class <code class="ph codeph">DataOutput</code>.</p></td>
</tr>
<tr class="odd">
<td><p>class <code class="ph codeph">apache::geode::client::DiskPolicyType</code></p></td>
<td><p>enum <code class="ph codeph">DiskPolicyType</code> plus static class <code class="ph codeph">DiskPolicy</code> containing convenience methods for <code class="ph codeph">DiskPolicyType</code> enumeration</p></td>
</tr>
<tr class="even">
<td><p>class <code class="ph codeph">apache::geode::client::DistributedSystem</code></p></td>
<td><p>Sealed class <code class="ph codeph">DistributedSystem</code></p></td>
</tr>
<tr class="odd">
<td><p>class <code class="ph codeph">apache::geode::client::EntryEvent</code></p></td>
<td><p>Sealed class <code class="ph codeph">EntryEvent</code></p></td>
</tr>
<tr class="even">
<td><p>class <code class="ph codeph">apache::geode::client::Exception</code></p></td>
<td><p>Class <code class="ph codeph">GeodeException</code></p></td>
</tr>
<tr class="odd">
<td><p>all other exceptions deriving from <code class="ph codeph">apache::geode::client::Exception</code></p></td>
<td><p>Corresponding exceptions deriving from <code class="ph codeph">GeodeException</code></p></td>
</tr>
<tr class="even">
<td><p>class <code class="ph codeph">apache::geode::client::ExpirationAction</code></p></td>
<td><p>enum <code class="ph codeph">ExpirationAction</code> plus static class <code class="ph codeph">Expiration</code> containing convenience methods for <code class="ph codeph">ExpirationAction</code> enumeration</p></td>
</tr>
<tr class="odd">
<td><p>class <code class="ph codeph">apache::geode::client::Log</code></p></td>
<td><p>Static class <code class="ph codeph">Log</code>. The native <code class="ph codeph">Log::log</code> method is mapped to <code class="ph codeph">Log.Write</code> to avoid the conflict with the class name which is reserved for the constructors of Log class. The various loglevel <code class="ph codeph">Throw</code> or <code class="ph codeph">Catch</code> methods are not implemented, since they are redundant to <code class="ph codeph">Log::Log</code> , <code class="ph codeph">Log::LogThrow</code>, and <code class="ph codeph">Log::LogCatch</code> methods that take <code class="ph codeph">LogLevel</code> as a parameter.</p></td>
</tr>
<tr class="even">
<td><p>enum <code class="ph codeph">apache::geode::client::MemberType</code></p></td>
<td><p>enum <code class="ph codeph">MemberType</code></p></td>
</tr>
<tr class="odd">
<td><p>abstract class <code class="ph codeph">apache::geode::client::PersistanceManager</code></p></td>
<td><p>Not provided. You can register a C++ implementation using <code class="ph codeph">AttributesFactory.SetPersistenceManager</code> but you cannot implement a new one in .NET</p></td>
</tr>
<tr class="even">
<td><p>class <code class="ph codeph">apache::geode::client::Properties</code></p></td>
<td><p>Sealed class <code class="ph codeph">Properties</code></p></td>
</tr>
<tr class="odd">
<td><p>class <code class="ph codeph">apache::geode::client::Properties::Visitor</code></p></td>
<td><p>Delegate <code class="ph codeph">PropertiesVisitor</code></p></td>
</tr>
<tr class="even">
<td><p>abstract class <code class="ph codeph">apache::geode::client::Region</code></p></td>
<td><p>Class <code class="ph codeph">IRegion</code></p></td>
</tr>
<tr class="odd">
<td><p>class <code class="ph codeph">apache::geode::client::RegionAttributes</code></p></td>
<td><p>Sealed class <code class="ph codeph">RegionAttributes</code></p></td>
</tr>
<tr class="even">
<td><p>class <code class="ph codeph">apache::geode::client::ScopeType</code></p></td>
<td><p>enum <code class="ph codeph">ScopeType</code> plus static class <code class="ph codeph">Scope</code> containing convenience methods for <code class="ph codeph">ScopeType</code> enumeration+</p></td>
</tr>
<tr class="odd">
<td><p>abstract class <code class="ph codeph">apache::geode::client::Serializable</code></p></td>
<td><p>Two options:</p>
<ul>
<li><p>Interface <code class="ph codeph">IPdxSerializable</code></p></li>
<li><p>Interface <code class="ph codeph">IGeodeSerializable</code> plus wrapper <code class="ph codeph">Serializable</code> class for native <code class="ph codeph">Serializable</code> and <code class="ph codeph">UserData</code> objects. The native <code class="ph codeph">toString</code> method is not provided, since the <code class="ph codeph">ToString</code> method of the base object class provides the same functionality.</p></li>
</ul></td>
</tr>
<tr class="even">
<td><p>class <code class="ph codeph">apache::geode::client::SystemProperties</code></p></td>
<td><p>Sealed class <code class="ph codeph">SystemProperties</code></p></td>
</tr>
<tr class="odd">
<td><p>class <code class="ph codeph">apache::geode::client::UserData</code></p></td>
<td><p>Two options:</p>
<ul>
<li><p>Interface <code class="ph codeph">IPdxSerializable</code></p></li>
<li><p>Interface <code class="ph codeph">IGeodeSerializable</code></p></li>
</ul></td>
</tr>
<tr class="even">
<td><p>class <code class="ph codeph">apache::geode::client::VectorT&lt;T&gt;</code></p></td>
<td><p>Array of the given type, such as T[]</p></td>
</tr>
</tbody>
</table>

<span class="tablecap">Table 1. C++ Class to .NET Class Mappings</span>

